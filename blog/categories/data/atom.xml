<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: data | The fastest and smoothest way to good architecture]]></title>
  <link href="http://hwyfwk.com/blog/categories/data/atom.xml" rel="self"/>
  <link href="http://hwyfwk.com/"/>
  <updated>2013-10-31T17:08:17-05:00</updated>
  <id>http://hwyfwk.com/</id>
  <author>
    <name><![CDATA[Tim Rayburn & Devlin Liles]]></name>
    <email><![CDATA[Team@HwyFwk.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Configuring Highway.Data]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/30/configuring-highway-dot-data-for-entity-framework/"/>
    <updated>2013-10-30T20:20:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/30/configuring-highway-dot-data-for-entity-framework</id>
    <content type="html"><![CDATA[<p>If you are using Highway.Data it is probably in conjunction with another underlying technology, so we have broken this guidance into several parts. Please feel free to jump to the part that pertains to you.</p>

<p><a href="EntityFramework">Entity Framework</a></p>

<p><a href="NHibernate">NHibernate</a></p>

<p><a href="RavenDB">RavenDB</a></p>

<p><a name="EntityFramework"></a></p>

<h1>EntityFramework</h1>

<h2>Getting Started</h2>

<p>The first step to getting Highway.Data running on Entity Framework is to install both Entity Framework and Highway.Data.EntityFramework with the below command.</p>

<p><code>plain
Install-Package Highway.Data.EntityFramework
</code></p>

<p>This will bring the install down and put it in our project.</p>

<h1>Example Domain</h1>

<p>In all of the examples below, we&rsquo;ll be working with the following business domain, from our Driver&rsquo;s Education company:</p>

<p>``` csharp
public class Instructor
{</p>

<pre><code>public int Id { get; set; }
public ICollection&lt;Driver&gt; Drivers { get; set; }
</code></pre>

<p>}</p>

<p>public class Driver
{</p>

<pre><code>public int Id { get; set; }
public string FirstName { get; set; }
public string LastName { get; set; }
public Car Car { get; set; }
</code></pre>

<p>}</p>

<p>public class Car
{</p>

<pre><code>public int Id { get; set; }
public string Make { get; set; }
public string Model { get; set; }
public string Year { get; set; }
</code></pre>

<p>}
```</p>

<h2>Database to Entity Mappings</h2>

<p>Now we need to create our database mappings. Highway.Data doesn&rsquo;t redefine the mapping syntax, it just makes them injectable into the <code>DataContext</code>. To do this we defined an interface <code>IMappingConfiguration</code> for you to implement that will allow us to inject your domain into a pre-built <code>DataContext</code>.
<strong>The best practice is to name this class after the aggregate root in your domain, so ours is DriverExams</strong></p>

<p>``` csharp
public class DriversExams : IMappingConfiguration
{</p>

<pre><code>public void ConfigureModelBuilder(DbModelBuilder modelBuilder)
{
    modelBuilder.Entity&lt;Driver&gt;(); //This is the inline/fluent config

    modelBuilder.Configurations.Add(new DriverMap()); //This is the class based config
}
</code></pre>

<p>}</p>

<p>public class DriverMap : EntityTypeConfiguration<Driver>
{</p>

<pre><code>public DriverMap()
{
    this.ToTable("Drivers");
    //You can do anything here that EF supports
}
</code></pre>

<p>}
```</p>

<p>That is all it takes to get our Database schema mapped to our entities. <em>As an aside, EF powertools will reference engineer the <code>EntityTypeConfiguration&lt;T&gt;</code> classes for you, and then you can just add them to your <code>IMappingConfiguration</code></em></p>

<h2>Context Level Configuration</h2>

<p>We setup a <code>DefaultContextConfiguration</code> by default, but if you disagree with our opinions about lazy loading etc.. you can change that. You just need to implement a class for <code>IContextConfiguration</code> like below.</p>

<p>``` csharp
public class DefaultContextConfiguration : IContextConfiguration
{</p>

<pre><code>public void ConfigureContext(DbContext context)
{
    context.Configuration.LazyLoadingEnabled = false;
    context.Configuration.ProxyCreationEnabled = false;
    //Here you can do any context level configuration changes that EF supports
}
</code></pre>

<p>}
```</p>

<p>This will let you change fundemental behavior of the context.</p>

<h2>Logging Configuration</h2>

<p>Then you need to send in a logger, but those details are covered in our <a href="/blog/2013/10/28/logging-with-datacontext/">Logging Post</a> because it is not Entity Framework specific.</p>

<h2>Using it all</h2>

<p>Last but not least we need to use our configured pieces like so:</p>

<p><code>csharp
var context = new DataContext("Your connection string here", new DriversExams(), new DefaultContextConfiguration(), new NoOpLogger());
</code></p>

<p>We normally do this via our favorite IoC Container, but alas that is another guide.</p>

<p><a name="NHibernate"></a></p>

<h1>NHibernate</h1>

<p>Highway.Data is very easy to configure with NHibernate, because we take in an ISession on Constructor for <code>DataContext</code>.</p>

<h2>Getting Started</h2>

<p>The first step to getting Highway.Data running on NHibernate is to install both NHibernate and Highway.Data with the below command.</p>

<p><code>plain
Install-Package Highway.Data.NHibernate
</code></p>

<p>This will bring the install down and put it in our project.</p>

<p>Everything else is out of the box NHibernate, isn&rsquo;t it great!!</p>

<h2>Example</h2>

<p>```csharp
var nhibernateConfiguration = new Configuration().Configure();</p>

<p>var model = AutoMap.AssemblyOf<Driver>()</p>

<pre><code>.Where(type =&gt; typeof (Driver).IsAssignableFrom(type))
.Conventions.AddFromAssemblyOf&lt;Driver&gt;()
.UseOverridesFromAssemblyOf&lt;Driver&gt;();
</code></pre>

<p>var factory = Fluently.Configure(nhibernateConfiguration).Mappings(mappingConfiguration => mappingConfiguration.AutoMappings.Add(model)).BuildSessionFactory();</p>

<p>var context = new DataContext(factory.OpenSession());</p>

<p>```</p>

<p><a name="RavenDB"></a></p>

<h1>RavenDB</h1>

<p>Highway.Data is very easy to configure with RavenDB, because we take in an <code>IDocumentSession</code> on Constructor for <code>DataContext</code>.</p>

<h2>Getting Started</h2>

<p>The first step to getting Highway.Data running on RavenDB is to install both RavenDB and Highway.Data with the below command.</p>

<p><code>plain
Install-Package Highway.Data.RavenDb
</code></p>

<p>This will bring the install down and put it in our project.</p>

<p>Everything else is out of the box RavenDB, isn&rsquo;t it great!!</p>

<h2>Example</h2>

<p>```csharp
var embeddableDocumentStore = new EmbeddableDocumentStore()
{</p>

<pre><code>DataDirectory = "",
RunInMemory = true
</code></pre>

<p>};
embeddableDocumentStore.Initialize();</p>

<p>var context = new DataContext(embeddableDocumentStore.OpenSession());</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Logging]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/28/logging-with-datacontext/"/>
    <updated>2013-10-28T17:59:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/28/logging-with-datacontext</id>
    <content type="html"><![CDATA[<p>We all have written/supported an application that had zero logging. It is like playing two sided blindfolded chess in the dark. We didn&rsquo;t want to pass that on to the users of Highway so logging is backed right into the toolset. We rely on <a href="http://www.nuget.org/packages/Common.Logging">Common.Logging</a> for our logging API, because this allows you, our users, to use your favorite logging facility. I am going to use a simple console logger for these examples, but it could be any Common.Logging adapter.</p>

<h1>Example Domain</h1>

<p>In all of the examples below, we&rsquo;ll be working with the following business domain, from our Driver&rsquo;s Education company:</p>

<p>``` csharp
public class Instructor
{</p>

<pre><code>public int Id { get; set; }
public ICollection&lt;Driver&gt; Drivers { get; set; }
</code></pre>

<p>}</p>

<p>public class Driver
{</p>

<pre><code>public int Id { get; set; }
public string FirstName { get; set; }
public string LastName { get; set; }
public Car Car { get; set; }
</code></pre>

<p>}</p>

<p>public class Car
{</p>

<pre><code>public int Id { get; set; }
public string Make { get; set; }
public string Model { get; set; }
public string Year { get; set; }
</code></pre>

<p>}
```</p>

<h1>Logging Output &ndash; It&rsquo;s Like Butter</h1>

<p>When you add an item there are several things that could/should happen. Knowing at which point the failure happens is important. This is where Highway Framework makes things easier on you. We want to know where the operations are executing and how the context is operating on a configurable level. This is going to use the standard log levels to get output from the system. Consider the following Test.</p>

<p>```
[TestMethod]
public void ShouldLogAtDebugLevel()
{</p>

<pre><code>//arrange 
var logger = new ConsoleOutLogger("Testing", LogLevel.Debug, true, true, true, @"dd/mm/yyyy hh:mm:ss");
var target = new DataContext(Settings.Default.Connection, new DriversEducationMappings(), logger);

//act
target.Add(new Driver("Devlin", "Liles"));
target.Add(new Driver("Tim", "Rayburn"));
target.Add(new Driver("Jay", "Smith"));
target.Add(new Driver("Brian", "Sullivan"));
target.Add(new Driver("Cori", "Drew"));

target.Commit();

foreach (var driver in target.AsQueryable&lt;Driver&gt;())
{
    target.Remove(driver);
}

target.Commit();

//assert
Assert.Inconclusive("We fail here to get the output from console nice and easy");
</code></pre>

<p>}
```
The output from this test is below</p>

<p><code>plain
30/40/2013 05:40:07 [DEBUG] Testing - Adding Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing - Adding Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing - Adding Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing - Adding Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing - Adding Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing -   Commited 5 Changes
30/40/2013 05:40:07 [DEBUG] Testing - Querying Object Driver
30/40/2013 05:40:07 [DEBUG] Testing - Queried Object Driver
30/40/2013 05:40:07 [DEBUG] Testing - Removing Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing - Removing Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing - Removing Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing - Removing Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing - Removing Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing -   Commited 5 Changes
</code></p>

<p>You can see that you get the step by step of what the application is doing on Debug but if you want even more information, you can up the game with LogLevel.Trace &ndash; This will trace every action start and finish.</p>

<p><code>plain
10/30/2013 5:49:10 PM [DEBUG] Testing - Adding Object Highway.DriversEducation.GettingStarted.Driver
10/30/2013 5:49:10 PM [TRACE] Testing - Added Object Highway.DriversEducation.GettingStarted.Driver
...
10/30/2013 5:49:10 PM [TRACE] Testing -     Commit
10/30/2013 5:49:10 PM [DEBUG] Testing -     Commited 5 Changes
10/30/2013 5:49:10 PM [DEBUG] Testing - Querying Object Driver
10/30/2013 5:49:10 PM [DEBUG] Testing - Queried Object Driver
10/30/2013 5:49:10 PM [DEBUG] Testing - Removing Object Highway.DriversEducation.GettingStarted.Driver
10/30/2013 5:49:10 PM [TRACE] Testing - Removed Object
...
10/30/2013 5:49:10 PM [TRACE] Testing -     Commit
10/30/2013 5:49:10 PM [DEBUG] Testing -     Commited 5 Changes
</code></p>

<p>This log level also lets you see the guts of when the model binding hits are being taken.</p>

<p><code>plain
10/30/2013 5:51:47 PM [DEBUG] Testing - Adding Object Highway.DriversEducation.GettingStarted.Driver
10/30/2013 5:51:47 PM [DEBUG] Testing -     OnModelCreating
10/30/2013 5:51:47 PM [TRACE] Testing -         Mapping : DriversEducationMappings
</code></p>

<p>Or Even when we execute a function/stored procedure</p>

<p><code>plain
10/30/2013 5:54:16 PM [TRACE] Testing - Executing SQL Select * from Drivers Where LastName = @lastName, with parameters lastName : Liles : String   
</code>
If you have code that is reloading objects to refresh them from the database using <code>Reload&lt;T&gt;(T item)</code> then you would see something like this.</p>

<p>``` plain</p>

<pre><code>10/30/2013 5:56:49 PM [TRACE] Testing - Retrieving State Entry For Object Highway.DriversEducation.GettingStarted.Driver
10/30/2013 5:56:49 PM [DEBUG] Testing - Reloading Object Highway.DriversEducation.GettingStarted.Driver
10/30/2013 5:56:49 PM [TRACE] Testing - Reloaded Object Highway.DriversEducation.GettingStarted.Driver
</code></pre>

<p>```</p>

<p>Keep an eye out because in the next version we will be introducing the following logging features.</p>

<ol>
<li>Repository Level Logging of Queries/Commands/Scalars</li>
<li>Non-Debugging Levels for always on health logging of the DataContext</li>
<li>Performance Logging on Trace Level for Commits and Repository Level Items</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eager Loading with Queries and Scalars]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/28/eager-loading-with-queries-and-scalars/"/>
    <updated>2013-10-28T17:38:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/28/eager-loading-with-queries-and-scalars</id>
    <content type="html"><![CDATA[<p>When we define a query, sometimes we need to load a graph of related objects as well. This can be impressively helpful with an ORM, but it is also more expensive per query. We have to balance the cost of the query graph with the ease of loading related objects in the code base. The approach to this varies by the underlying ORM that you are using, so please click the link for the section that pertains to you.</p>

<p><a href="#ef">Entity Framework</a></p>

<p><a href="#nhibernate">NHibernate</a></p>

<h1>Example Domain</h1>

<p>In all of the examples below, we&rsquo;ll be working with the following business domain, from our Driver&rsquo;s Education company:</p>

<p>``` csharp
public class Instructor
{</p>

<pre><code>public int Id { get; set; }
public ICollection&lt;Driver&gt; Drivers { get; set; }
</code></pre>

<p>}</p>

<p>public class Driver
{</p>

<pre><code>public int Id { get; set; }
public string FirstName { get; set; }
public string LastName { get; set; }
public Car Car { get; set; }
</code></pre>

<p>}</p>

<p>public class Car
{</p>

<pre><code>public int Id { get; set; }
public string Make { get; set; }
public string Model { get; set; }
public string Year { get; set; }
</code></pre>

<p>}</p>

<p>public class InstructorById : Scalar<Instructor>
{</p>

<pre><code>public InstructorById(int id)
{
    ContextQuery = context =&gt; context.AsQueryable&lt;Instructor&gt;()
                                     .SingleOrDefault(e =&gt; e.Id == id);
}
</code></pre>

<p>}
```</p>

<h2>Use Case</h2>

<p>Let&rsquo;s assume that we now need to load Drivers and Cars for the instructor. Because we are only loading one Instructor this should be fairly light weight on the database.</p>

<p><a name="ef"></a></p>

<h1>Entity Framework</h1>

<p>Entity Framework got the API for this correct, so when you unit test this without a database it does nothing with the include call. This allows us to not need an advanced query for the Entity Framework version of the query.</p>

<p>```
public class InstructorById : Scalar<Instructor>
{</p>

<pre><code>public InstructorById(int id)
{
    ContextQuery = context =&gt; context.AsQueryable&lt;Instructor&gt;()
                                .Include(x =&gt; x.Drivers.Select(c =&gt; c.Car))
                                .SingleOrDefault(e =&gt; e.Id == id);
}
</code></pre>

<p>}
<code>``
Notice to traverse a collection we have to use the</code>Select` method, this is a quark of LINQ and Entity Framework. As you see below in the NHibernate solution there is a slightly more elegant way they could have done this, but it comes with a hefty cost.</p>

<p><a name="nhibernate"></a></p>

<h1>NHibernate</h1>

<p>In the NHibernate usage we will have to bind ourselves to their specific API, which means that we will have to use an <code>AdvancedQuery</code>.
```
public class InstructorById : AdvancedScalar<Instructor>
{</p>

<pre><code>public InstructorById(int id)
{
    ContextQuery = context =&gt; context.Query&lt;Instructor&gt;()
                                .FetchMany(x =&gt; x.Drivers)  
                                .ThenFetch(x =&gt; x.Car)
                                .SingleOrDefault(e =&gt; e.Id == id);
}
</code></pre>

<p>}
<code>
This reads more fluently but causes us to be bound to NHibernate. **It also has one massive bug in NHibernate's LINQ provider.** In the above query you will only get one related driver and one related car. This is because it applies a Top 1 to the queries. To avoid this you must do the below query.
</code>
public class InstructorById : AdvancedScalar<Instructor>
{</p>

<pre><code>public InstructorById(int id)
{
    ContextQuery = context =&gt; context.Query&lt;Instructor&gt;()
                                .FetchMany(x =&gt; x.Drivers)  
                                .ThenFetch(x =&gt; x.Car)
                                .Where(e =&gt; e.Id == id)
                                .ToList() // This forces execution without the Top 1 of a single or default
                                .SingleOrDefault();
}
</code></pre>

<p>}
```
<strong>This is a bug in NHibernate</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Performance Testing Queries]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/27/performance-testing-queries/"/>
    <updated>2013-10-27T16:31:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/27/performance-testing-queries</id>
    <content type="html"><![CDATA[<p>When dealing with data access you should always adhere to Jackson&rsquo;s rules of optimization. For convenience they are right here:</p>

<h3>M.A. Jackson (Principles of Program Design, 1975) wrote:</h3>

<p><strong>Rule 1.</strong> Don&rsquo;t do it</p>

<p><strong>Rule 2. (for experts only)</strong> Don&rsquo;t do it yet.</p>

<p>Performance optimization should only be done when needed, but when you need to it should be easy to execute and to measure. With this in mind, Highway took some of the heavy lifting out of the hands of the developers. This is normally the tools that we will use to identify a query that is not performing up to par so we can change it. Let&rsquo;s take the previous example of deleting all cars of a certain make.</p>

<h1>Example Domain</h1>

<p>In all of the examples below, we&rsquo;ll be working with the following business domain, from our Driver&rsquo;s Education company:</p>

<p>``` csharp
public class Car
{</p>

<pre><code>public int Id { get; set; }
public string Make { get; set; }
public string Model { get; set; }
public string Year { get; set; }
</code></pre>

<p>}</p>

<p>public class DropMake : Command
{</p>

<pre><code>public DropMake(string make)
{
    // THIS IS A REALLY BAD WAY TO REMOVE MULTIPLE ROWS
    // IT WOULD NORMALLY BE MUCH BETTER TO USE AN
    // AdvancedCommand TO PERFORM THIS TYPE OF OPERATION
    ContextQuery = c =&gt;
    {
        var cars = c.AsQueryable&lt;Car&gt;().Where(car =&gt; car.Make == make);
        foreach (var car in cars)
        {
            c.Remove(car);
        }
    };
}
</code></pre>

<p>}
```</p>

<h1>Performance Tests</h1>

<h2>These should <em>ideally</em> run against production like data</h2>

<p>I am going to use a command for delete, but this could be just as easily done with a <code>Scalar</code> or <code>Query</code>.</p>

<p>We want to measure the time it takes to execute the query and measure it against our maximum. If you cannot define a specific maximum for the test, you should look at Jackson rule 1. If your maximum doesn&rsquo;t fail this test, look at Jackson rule 2.</p>

<p>```
[TestMethod]
public void ShouldDeleteInUnder250Milliseconds()
{</p>

<pre><code>var context = new DataContext(Settings.Default.Connection, new DataMappings());

var dropMake = new DropMake("Chevy");

dropMake.RunPerformanceTest(context,false,250);
</code></pre>

<p>}
```</p>

<p>If the time exceeds maximum the performance test will throw an exception which will fail the test. The time and expected are in the exception.</p>

<p>Let&rsquo;s take a closer look at this line
<code>
dropMake.RunPerformanceTest(context,false,250);
</code>
The 1st parameter, context, is the data connection we use to execute the test.</p>

<p>The 2nd parameter, false, is a flag telling us to include the start up time of the context in the total time. This is useful with ORMs like Entity Framework or NHibernate that have a large one time cost on start up. We give you the option of excluding that time from your evaluation.</p>

<p>The 3rd parameter, 250, is the total milliseconds allowed for the execution. If it exceeds this the test fails.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Advanced Queries / Commands /Scalars]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/25/advanced-queries-slash-commands-slash-scalars/"/>
    <updated>2013-10-25T15:11:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/25/advanced-queries-slash-commands-slash-scalars</id>
    <content type="html"><![CDATA[<p>Surround your pullquote like this {" text to be quoted "}</p>

<p>All of the <code>AdvancedQuery</code>, <code>AdvancedScalar</code>, and <code>AdvancedCommand</code> are an opt in process for one reason, <strong>it requires that you bind your implementation of the query to the underlying technology.</strong> This is not something to take lightly, but sometimes it is needed.</p>

<h1>Example Domain</h1>

<p>In all of the examples below, we&rsquo;ll be working with the following business domain, from our Driver&rsquo;s Education company:</p>

<p>``` csharp
public class Instructor
{</p>

<pre><code>public int Id { get; set; }
public ICollection&lt;Driver&gt; Drivers { get; set; }
</code></pre>

<p>}</p>

<p>public class Driver
{</p>

<pre><code>public int Id { get; set; }
public string FirstName { get; set; }
public string LastName { get; set; }
public int Score { get; set; }
public Instructor Instructor { get; set; }
</code></pre>

<p>}</p>

<p>public class Car
{</p>

<pre><code>public int Id { get; set; }
public string Make { get; set; }
public string Model { get; set; }
public string Year { get; set; }
</code></pre>

<p>}</p>

<p>public class Top5PercentileOfDrivers : Query<Driver>
{</p>

<pre><code>public Top5PercentileOfDrivers()
{
    ContextQuery = context =&gt;
    {
        var scores = context.AsQueryable&lt;Driver&gt;().Select(x =&gt; x.Score);
        int percentileScore =
            Convert.ToInt32(Math.Round((5/100)*scores.Count() + 0.5, MidpointRounding.AwayFromZero));
        return context.AsQueryable&lt;Driver&gt;().OrderByDescending(x =&gt; x.Score).Take(percentileScore);
    };
}
</code></pre>

<p>}</p>

<p>public class SwapInstructors : Scalar<int>
{</p>

<pre><code>public SwapInstructores(Instructor currentInstructor, Instructor newInstructor)
{
    ContextQuery = context =&gt;
    {
        foreach(var driver in currentInstructor.Drivers)
        {
            driver.Instructor = newInstructor;
        }
        context.Commit();
    };
}
</code></pre>

<p>}</p>

<p>public class DropMake : Command
{</p>

<pre><code>public DropMake(string make)
{
    // THIS IS A REALLY BAD WAY TO REMOVE MULTIPLE ROWS
    // IT WOULD NORMALLY BE MUCH BETTER TO USE AN
    // AdvancedCommand TO PERFORM THIS TYPE OF OPERATION
    ContextQuery = c =&gt;
    {
        var cars = c.AsQueryable&lt;Car&gt;().Where(car =&gt; car.Make == make);
        foreach (var car in cars)
        {
            c.Remove(car);
        }
    };
}
</code></pre>

<p>}
```</p>

<h1>Advanced Query &ndash; Sometimes you need a Stored Procedure</h1>

<p>In the case where we want to do large set based calculation it makes sense to use the power of the underlying persistence engine. Databases have been designed for set based operations, and here is where the power of stored procedures or parameterized SQL comes in. We are going to use a stored procedure to return the top 5 percentile of drivers that have used our training service. The advanced version of this would be below.</p>

<p>```
public class Top5PercentileOfDrivers : AdvancedQuery<Driver>
{</p>

<pre><code>public Top5PercentileOfDrivers()
{
    ContextQuery = context =&gt; context.ExecuteSqlQuery&lt;Driver&gt;("exec topPercentileDrivers @percentile", new SqlParameter("percentile",5));
}
</code></pre>

<p>}
```</p>

<h1>Advanced Commands &ndash;  When you need a hammer</h1>

<p>Surround your pullquote like this {" text to be quoted "}
```
public class DropMake : AdvancedCommand
{</p>

<pre><code>public DropMake(string make)
{
    ContextQuery = c =&gt; c.ExecuteSqlCommand("DELETE FROM Cars WHERE Make = @make",new DbParameter[] {new SqlParameter("make", make)});
}
</code></pre>

<p>}
```</p>

<h1>Advanced Scalar</h1>

<p>In the instance that we need to make a lot of changes but also return some value from the database, we can use an <code>AdvancedScalar</code>.
```
public class SwapInstructores : AdvancedScalar<int>
{</p>

<pre><code>public SwapInstructores(Instructor currentInstructor, Instructor newInstructor)
{
    DbParameter[] parameters = new DbParameter[]
    {
        new SqlParameter("old", currentInstructor.Id),
        new SqlParameter("new", newInstructor.Id), 
    };
    ContextQuery = c =&gt; c.ExecuteSqlCommand("UPDATE DRIVERS SET InstructorId = @new WHERE InstructorId = @old", parameters);
}
</code></pre>

<p>}
```</p>

<p>Each of these examples gives one of the many usages of <code>AdvancedQuery</code>/<code>AdvancedCommand</code>/<code>AdvancedScalar</code>, but when you need the underlying provider this is your route. When used carefully this allows us to serve both the the needs of our application, but also the needs of our data storage.</p>
]]></content>
  </entry>
  
</feed>
