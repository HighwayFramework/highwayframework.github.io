<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: data | The fastest and smoothest way to good architecture]]></title>
  <link href="http://hwyfwk.com/blog/categories/data/atom.xml" rel="self"/>
  <link href="http://hwyfwk.com/"/>
  <updated>2014-01-25T20:07:51-06:00</updated>
  <id>http://hwyfwk.com/</id>
  <author>
    <name><![CDATA[Tim Rayburn & Devlin Liles]]></name>
    <email><![CDATA[Team@HwyFwk.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Simplified Creation Patterns]]></title>
    <link href="http://hwyfwk.com/blog/2014/01/25/simplified-creation-patterns/"/>
    <updated>2014-01-25T16:45:00-06:00</updated>
    <id>http://hwyfwk.com/blog/2014/01/25/simplified-creation-patterns</id>
    <content type="html"><![CDATA[<h1>Simplified Creation Patterns</h1>

<h3>Repository Factory</h3>

<p>We wanted to provide a simple way to construct both domain repositories and simple Repositories. This lead us to create two different factories for repository. We ship a default factory for both of these, but we also ship interfaces for these as a test and extension point.</p>

<h4>Repository Factory</h4>

<p>This allows you to construct a simple repository that doesn&rsquo;t need any of the <code>DomainRepository</code> features.</p>

<p>```</p>

<pre><code>public interface IRepositoryFactory
{
    /// &lt;summary&gt;
    /// Creates a repository for the requested domain
    /// &lt;/summary&gt;
    /// &lt;returns&gt;Domain specific repository&lt;/returns&gt;
    IRepository Create();
}
</code></pre>

<p>```</p>

<h4>Domain Repository Factory</h4>

<p>This allows you construct a repository specific to any domain that the factory is dependent on.</p>

<p>```</p>

<pre><code>public interface IDomainRepositoryFactory
{

    /// &lt;summary&gt;
    /// Creates a repository for the specified &lt;see cref="IDomain"/&gt;
    /// &lt;/summary&gt;
    /// &lt;typeparam name="T"&gt;Domain for repository&lt;/typeparam&gt;
    /// &lt;returns&gt;&lt;see cref="IRepository"/&gt;&lt;/returns&gt;
    IRepository Create&lt;T&gt;() where T : class, IDomain;

    /// &lt;summary&gt;
    /// Creates a repository for the specified &lt;see cref="IDomain"/&gt;
    /// &lt;/summary&gt;
    /// &lt;param name="T"&gt;Domain for repository&lt;/param&gt;
    /// &lt;returns&gt;&lt;see cref="IRepository"/&gt;&lt;/returns&gt;
    IRepository Create(Type type);
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Domain Context]]></title>
    <link href="http://hwyfwk.com/blog/2014/01/25/domain-context/"/>
    <updated>2014-01-25T16:42:00-06:00</updated>
    <id>http://hwyfwk.com/blog/2014/01/25/domain-context</id>
    <content type="html"><![CDATA[<h1>Domain Context and Domain Driven Design (DDD) Patterns</h1>

<h2>Why did you support DDD?</h2>

<p>We have been working in large complex applications for the last several projects and found some rough edges around both business logic and data access. These edges come from not separating the business concepts effectively in code. Long running business sagas being isolated helped to solve this. We added this advanced support to Highway.Data to help make this easier for us, and those like us that have drank the DDD punch.</p>

<h2>How did you support DDD?</h2>

<p>We added a few classes to help support the ability to create domain bounded contexts. These use a generic type parameter to define which domain they contain, and also to segregate the in memory cache for mappings. This allows us to load differing views on similar objects.</p>

<h3>IDomainRepository</h3>

<p>This repository has the event interception events, as well as the bounded context.</p>

<p>``` csharp</p>

<pre><code>public interface IDomainRepository&lt;in T&gt; where T : class
{
    event EventHandler&lt;BeforeQuery&gt; BeforeQuery;

    event EventHandler&lt;BeforeScalar&gt; BeforeScalar;

    event EventHandler&lt;BeforeCommand&gt; BeforeCommand;

    event EventHandler&lt;AfterQuery&gt; AfterQuery;

    event EventHandler&lt;AfterScalar&gt; AfterScalar;

    event EventHandler&lt;AfterCommand&gt; AfterCommand;

    IDomainContext&lt;T&gt; DomainContext { get; } 
}
</code></pre>

<p>```</p>

<h3>IDomainContext</h3>

<p>This context holds the context level interception events, and is contrained to a <code>IDomain</code> type.</p>

<p>```</p>

<pre><code>public interface IDomainContext&lt;in T&gt; : IDataContext where T : class
{
    /// &lt;summary&gt;
    ///     The event fired just before the commit of the persistence
    /// &lt;/summary&gt;
    event EventHandler&lt;BeforeSave&gt; BeforeSave;

    /// &lt;summary&gt;
    ///     The event fired just after the commit of the persistence
    /// &lt;/summary&gt;
    event EventHandler&lt;AfterSave&gt; AfterSave;
}
</code></pre>

<p>```</p>

<h3>IDomain</h3>

<p>This is the interface that you implement to define a domain for your objects. It includes any event interceptors, context configurations, connection string, and object mappings.</p>

<p>```</p>

<pre><code>public interface IDomain
{
    string ConnectionString { get; }

    IMappingConfiguration Mappings { get;}

    IContextConfiguration Context { get; }

    List&lt;IInterceptor&gt; Events { get; }
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Highway.Data v5.0 Released]]></title>
    <link href="http://hwyfwk.com/blog/2014/01/25/highway-dot-data-v5-dot-0-released/"/>
    <updated>2014-01-25T16:40:00-06:00</updated>
    <id>http://hwyfwk.com/blog/2014/01/25/highway-dot-data-v5-dot-0-released</id>
    <content type="html"><![CDATA[<h1>Highway.Data 5.0 Released ( 5.0.1.0 )</h1>

<h2>New Features, and better Domain Driven Design support</h2>

<h3>Domain Context</h3>

<p>We have added support for advanced domain specific contexts. These allow for detailed manipulation of your data access patterns. It adheres to the Domain Driven version of a bounded context.</p>

<h4>More Details are here: <a href="/blog/2014/01/25/domain-context/">Domain Context</a></h4>

<h3>Simplified Creation Pattern</h3>

<p>We have also added the much requested <code>Repository</code> factories. These give you the ability to use Highway.Data in services and long living work-flows without having to hand roll your own management of unit of work.</p>

<h4>More Details are here: <a href="/blog/2014/01/25/simplified-creation-patterns/">Creation Patterns</a></h4>

<h3>Entity Framework 6.0.0.2 Support</h3>

<p>We shipped an EF 6.0 supported version now that some of the initial release bugs have been patch. We did require the 6.0.0.2 version so that we could make sure you get their fixes as well.</p>

<p>We will be working over the next 3-4 weeks to support some of the new features ( that we don&rsquo;t already support) in Entity Framework 6.0.</p>

<h4>More Details are here:  <a href="http://msdn.microsoft.com/en-us/data/ee712907#ef6">EF 6.0</a></h4>

<h2>Breaking Changes:</h2>

<h3>AsQueryable off Repository.Context</h3>

<p>After seeing a lot of examples from clients, friends, and other speakers using <code>repository.Context.AsQueryable()</code>, we realized that this represented a large hole in the design pattern for Query Object separation. We have remove that hole this publish. If you were using this for simple operations please look at the pre-built queries, or codify the queries into <code>Query&lt;T&gt;, Scalar&lt;T&gt;, Command&lt;T&gt;</code> objects.</p>

<h3>Interception</h3>

<p>We have disabled event interception for the simple <code>DataContext</code> as it caused an additional understanding and performance overhead. This is in an effort make sure we have a simple entry story for most developers. If you were using this feature, we have good news. We have expanded the feature with pre/post <code>Command</code>, <code>Scalar</code>, and <code>Query</code> execution intercept points, as well as kept the standard pre/post save. These features have moved onto the <code>DomainContext&lt;T&gt;</code> class due to their advanced nature.</p>

<h4>More Details are here:</h4>

<h2>Thanks to:</h2>

<h4>Curtis Schlak for pushing us to get EF 6.0 support published.</h4>

<h4>Michael Dudley for the design sessions on vacation in Las Vegas, and the push to finish the beta release.</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How do I get my DbContext?]]></title>
    <link href="http://hwyfwk.com/blog/2013/11/14/how-do-i-get-my-dbcontext/"/>
    <updated>2013-11-14T11:10:00-06:00</updated>
    <id>http://hwyfwk.com/blog/2013/11/14/how-do-i-get-my-dbcontext</id>
    <content type="html"><![CDATA[<p>From time to time it is necessary to either pass a <code>DbContext</code> to some framework code that expects it, or to know the type of your <code>DbContext</code>, for instance when setting a database initializer.  The answer depends slightly on which part of Highway your using, as follows:</p>

<ul>
<li>In Highway.Data.EntityFramework, the <code>DataContext</code> class is a child of <code>DbContext</code>.  As such anywhere you need <code>DbContext</code>, simply pass your instance of <code>IDataContext</code> as <code>DbContext</code>.  This may require a soft cast if your variable is of type <code>IDataContext</code> and not <code>DataContext</code>, which it normally should and will be.</li>
<li>In Highway.OnRamp.MVC.Data we subclass the default <code>DataContext</code> class of Highway.Data.EntityFramework into a class called <code>HighwayDataContext</code> to change the constructor a bit.  As such, the type of of your <code>DbContext</code> is <code>HighwayDataContext</code>, but as above any <code>IDataContext</code> can be cast to <code>DbContext</code> with success.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Does Highway.Data work with Database First?]]></title>
    <link href="http://hwyfwk.com/blog/2013/11/07/does-highway-dot-data-work-with-database-first/"/>
    <updated>2013-11-07T15:32:00-06:00</updated>
    <id>http://hwyfwk.com/blog/2013/11/07/does-highway-dot-data-work-with-database-first</id>
    <content type="html"><![CDATA[<h2>Short Answer</h2>

<p>Yes, sort of.</p>

<h2>Long Answer</h2>

<p>Inject-able mappings and context configuration are not offered, for obvious reasons. Otherwise in this version all other features are supported.</p>

<h2>A word about the future</h2>

<p>In future versions of Highway.Data, it is highly likely that features will be introduced that are not compatible with Database First.  How we handle this will be decided later, but this is not a feature which we are committed to fully supporting, it is provided as a <strong>basic</strong> scenario.</p>

<h3>Entity Framework Power Tools</h3>

<p>As a quick word, most people who have chosen Database First, did so because they believed that Code First would require that their classes create, or otherwise control their database.  This is not the case.  <a href="http://visualstudiogallery.msdn.microsoft.com/72a60b14-1581-4b9b-89f2-846072eff19d">The Entity Framework team has for some time shipped a set of Power Tools</a> which allow the reverse engineering of existing database into Code First entities and mappings, which are then fully compatible with Highway.Data.  We encourage those currently using Database First to migrate using these tools to a Code First solution.</p>
]]></content>
  </entry>
  
</feed>
