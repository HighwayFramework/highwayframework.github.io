<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: data | The fastest and smoothest way to good architecture]]></title>
  <link href="http://hwyfwk.com/blog/categories/data/atom.xml" rel="self"/>
  <link href="http://hwyfwk.com/"/>
  <updated>2013-11-07T15:29:12-06:00</updated>
  <id>http://hwyfwk.com/</id>
  <author>
    <name><![CDATA[Tim Rayburn & Devlin Liles]]></name>
    <email><![CDATA[Team@HwyFwk.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[What should I register with my IoC container?]]></title>
    <link href="http://hwyfwk.com/blog/2013/11/07/what-should-i-register-with-my-ioc-container/"/>
    <updated>2013-11-07T15:09:00-06:00</updated>
    <id>http://hwyfwk.com/blog/2013/11/07/what-should-i-register-with-my-ioc-container</id>
    <content type="html"><![CDATA[<p>If you are going to use an IoC container, regardless of which one, here is what needs to be registered, and some thoughts about object lifetime.  If we do not specify a lifetime, you can assume that singleton is acceptable.</p>

<h2>Highway.Data</h2>

<ul>
<li><code>IRepository</code> should resolve to <code>Repository</code> on either a transient (new every request) or per web request (if you&rsquo;re in a website) object lifetime.</li>
<li><code>IEventManager</code> should resolve to <code>EventManager</code></li>
<li><code>ILog</code> should resolve to either a <a href="http://netcommon.sourceforge.net/">Common.Logging</a> implementation for your chosen logger, or an instance of <code>NoOpLogger</code> from <a href="http://netcommon.sourceforge.net/">Common.Logging</a>.</li>
</ul>


<h2>Highway.Data.EntityFramework</h2>

<ul>
<li><code>IDataContext</code> should resolve to <code>DataContext</code> on either a transient (new every request).

<ul>
<li>Your IoC will need to inject a connection string, named <code>connectionString</code> to the constructor, in whatever way such primitive dependencies are handled by your container.</li>
</ul>
</li>
<li><code>IMappingConfiguration</code> should resolve to a type you have created that implements this interface and maps all of your entities.</li>
<li><code>IContextConfiguration</code> should resolve to <code>DefaultContextConfiguration</code> <strong>or</strong> a class you&rsquo;ve created should you need to change how the Context is configured from our defaults.</li>
</ul>


<h2>Highway.Data.NHibernate</h2>

<ul>
<li><code>IDataContext</code> should resolve to <code>DataContext</code> on either a transient (new every request).</li>
<li><code>ISession</code> should resolve to a call to your configured <code>ISessionFactory</code>.  These are standard NHibernate interfaces, and you should follow their guidance regarding object lifetime.</li>
</ul>


<h2>Highway.Data.RavenDb</h2>

<ul>
<li><code>IDataContext</code> should resolve to <code>DataContext</code> on either a transient (new every request).</li>
<li><code>IDocumentSession</code> should resolve to a call to your configured <code>IDocumentStore</code>.  These are standard RavenDb interfaces, and you should follow their guidance regarding object lifetime.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How do I fix this 'Reference to type * could not be found' error?]]></title>
    <link href="http://hwyfwk.com/blog/2013/11/06/how-do-i-fix-this-reference-to-type-star-could-not-be-found-error/"/>
    <updated>2013-11-06T07:49:00-06:00</updated>
    <id>http://hwyfwk.com/blog/2013/11/06/how-do-i-fix-this-reference-to-type-star-could-not-be-found-error</id>
    <content type="html"><![CDATA[<p>In Highway.Data 4.1  we added strong name keys (SNKs) to all assemblies.  This was a good thing, but bad version number handling and unfortunately can&rsquo;t be fixed now that it&rsquo;s in the wild.  This most often presents itself as an error similar to :</p>

<p><code>
Reference to type 'Highway.Data.IContextConfiguration`1' claims it is defined in 'C:\source\MyProject\packages\Highway.Data.4.0.5.3\lib\net40\Highway.Data.dll', but it could not be found
</code></p>

<p>The particular type that it complains about (<code>IContextConfiguration&lt;T&gt;</code> in this case) may vary case to case, but the combination of a <code>Reference to type * could not be found</code> and that error references a version prior to v4.1 are the signs that you&rsquo;ve encountered this bug.</p>

<h2>Resolution</h2>

<p>Unfortunately, any components that depended on the pre-v4.1 assemblies will need to be recompiled.  Because the SNK was added there is no Assembly Binding Redirect or other solution to this, we suck, and we&rsquo;re sorry.  Rest assured that all future Highway Framework assemblies will be signed from day one and that we&rsquo;ve learned this lesson.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Configuring Highway.Data]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/30/configuring-highway-dot-data-for-entity-framework/"/>
    <updated>2013-10-30T20:20:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/30/configuring-highway-dot-data-for-entity-framework</id>
    <content type="html"><![CDATA[<p>If you are using Highway.Data it is probably in conjunction with another underlying technology, so we have broken this guidance into several parts. Please feel free to jump to the part that pertains to you.</p>

<p><a href="#EntityFramework">Entity Framework</a></p>

<p><a href="#NHibernate">NHibernate</a></p>

<p><a href="#RavenDB">RavenDB</a></p>

<p><a name="EntityFramework"></a></p>

<h1>EntityFramework</h1>

<h2>Getting Started</h2>

<p>The first step to getting Highway.Data running on Entity Framework is to install both Entity Framework and Highway.Data.EntityFramework with the below command.</p>

<p><code>plain
Install-Package Highway.Data.EntityFramework
</code></p>

<p>This will bring the install down and put it in our project.</p>

<h1>Example Domain</h1>

<p>In all of the examples below, we&rsquo;ll be working with the following business domain, from our Driver&rsquo;s Education company:</p>

<p>``` csharp
public class Instructor
{</p>

<pre><code>public int Id { get; set; }
public ICollection&lt;Driver&gt; Drivers { get; set; }
</code></pre>

<p>}</p>

<p>public class Driver
{</p>

<pre><code>public int Id { get; set; }
public string FirstName { get; set; }
public string LastName { get; set; }
public Car Car { get; set; }
</code></pre>

<p>}</p>

<p>public class Car
{</p>

<pre><code>public int Id { get; set; }
public string Make { get; set; }
public string Model { get; set; }
public string Year { get; set; }
</code></pre>

<p>}
```</p>

<h2>Database to Entity Mappings</h2>

<p>Now we need to create our database mappings. Highway.Data doesn&rsquo;t redefine the mapping syntax, it just makes them injectable into the <code>DataContext</code>. To do this we defined an interface <code>IMappingConfiguration</code> for you to implement that will allow us to inject your domain into a pre-built <code>DataContext</code>.
<strong>The best practice is to name this class after the aggregate root in your domain, so ours is DriverExams</strong></p>

<p>``` csharp
public class DriversExams : IMappingConfiguration
{</p>

<pre><code>public void ConfigureModelBuilder(DbModelBuilder modelBuilder)
{
    modelBuilder.Entity&lt;Driver&gt;(); //This is the inline/fluent config

    modelBuilder.Configurations.Add(new DriverMap()); //This is the class based config
}
</code></pre>

<p>}</p>

<p>public class DriverMap : EntityTypeConfiguration<Driver>
{</p>

<pre><code>public DriverMap()
{
    this.ToTable("Drivers");
    //You can do anything here that EF supports
}
</code></pre>

<p>}
```</p>

<p>That is all it takes to get our Database schema mapped to our entities. <em>As an aside, EF powertools will reference engineer the <code>EntityTypeConfiguration&lt;T&gt;</code> classes for you, and then you can just add them to your <code>IMappingConfiguration</code></em></p>

<h2>Context Level Configuration</h2>

<p>We setup a <code>DefaultContextConfiguration</code> by default, but if you disagree with our opinions about lazy loading etc.. you can change that. You just need to implement a class for <code>IContextConfiguration</code> like below.</p>

<p>``` csharp
public class DefaultContextConfiguration : IContextConfiguration
{</p>

<pre><code>public void ConfigureContext(DbContext context)
{
    context.Configuration.LazyLoadingEnabled = false;
    context.Configuration.ProxyCreationEnabled = false;
    //Here you can do any context level configuration changes that EF supports
}
</code></pre>

<p>}
```</p>

<p>This will let you change fundemental behavior of the context.</p>

<h2>Logging Configuration</h2>

<p>Then you need to send in a logger, but those details are covered in our <a href="/blog/2013/10/28/logging-with-datacontext/">Logging Post</a> because it is not Entity Framework specific.</p>

<h2>Using it all</h2>

<p>Last but not least we need to use our configured pieces like so:</p>

<p><code>csharp
var context = new DataContext("Your connection string here", new DriversExams(), new DefaultContextConfiguration(), new NoOpLogger());
</code></p>

<p>We normally do this via our favorite IoC Container, but alas that is another guide.</p>

<p><a name="NHibernate"></a></p>

<h1>NHibernate</h1>

<p>Highway.Data is very easy to configure with NHibernate, because we take in an ISession on Constructor for <code>DataContext</code>.</p>

<h2>Getting Started</h2>

<p>The first step to getting Highway.Data running on NHibernate is to install both NHibernate and Highway.Data with the below command.</p>

<p><code>plain
Install-Package Highway.Data.NHibernate
</code></p>

<p>This will bring the install down and put it in our project.</p>

<p>Everything else is out of the box NHibernate, isn&rsquo;t it great!!</p>

<h2>Example</h2>

<p>```csharp
var nhibernateConfiguration = new Configuration().Configure();</p>

<p>var model = AutoMap.AssemblyOf<Driver>()</p>

<pre><code>.Where(type =&gt; typeof (Driver).IsAssignableFrom(type))
.Conventions.AddFromAssemblyOf&lt;Driver&gt;()
.UseOverridesFromAssemblyOf&lt;Driver&gt;();
</code></pre>

<p>var factory = Fluently.Configure(nhibernateConfiguration).Mappings(mappingConfiguration => mappingConfiguration.AutoMappings.Add(model)).BuildSessionFactory();</p>

<p>var context = new DataContext(factory.OpenSession());</p>

<p>```</p>

<p><a name="RavenDB"></a></p>

<h1>RavenDB</h1>

<p>Highway.Data is very easy to configure with RavenDB, because we take in an <code>IDocumentSession</code> on Constructor for <code>DataContext</code>.</p>

<h2>Getting Started</h2>

<p>The first step to getting Highway.Data running on RavenDB is to install both RavenDB and Highway.Data with the below command.</p>

<p><code>plain
Install-Package Highway.Data.RavenDb
</code></p>

<p>This will bring the install down and put it in our project.</p>

<p>Everything else is out of the box RavenDB, isn&rsquo;t it great!!</p>

<h2>Example</h2>

<p>```csharp
var embeddableDocumentStore = new EmbeddableDocumentStore()
{</p>

<pre><code>DataDirectory = "",
RunInMemory = true
</code></pre>

<p>};
embeddableDocumentStore.Initialize();</p>

<p>var context = new DataContext(embeddableDocumentStore.OpenSession());</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Logging]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/28/logging-with-datacontext/"/>
    <updated>2013-10-28T17:59:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/28/logging-with-datacontext</id>
    <content type="html"><![CDATA[<p>We all have written/supported an application that had zero logging. It is like playing two sided blindfolded chess in the dark. We didn&rsquo;t want to pass that on to the users of Highway so logging is backed right into the toolset. We rely on <a href="http://www.nuget.org/packages/Common.Logging">Common.Logging</a> for our logging API, because this allows you, our users, to use your favorite logging facility. I am going to use a simple console logger for these examples, but it could be any Common.Logging adapter.</p>

<h1>Example Domain</h1>

<p>In all of the examples below, we&rsquo;ll be working with the following business domain, from our Driver&rsquo;s Education company:</p>

<p>``` csharp
public class Instructor
{</p>

<pre><code>public int Id { get; set; }
public ICollection&lt;Driver&gt; Drivers { get; set; }
</code></pre>

<p>}</p>

<p>public class Driver
{</p>

<pre><code>public int Id { get; set; }
public string FirstName { get; set; }
public string LastName { get; set; }
public Car Car { get; set; }
</code></pre>

<p>}</p>

<p>public class Car
{</p>

<pre><code>public int Id { get; set; }
public string Make { get; set; }
public string Model { get; set; }
public string Year { get; set; }
</code></pre>

<p>}
```</p>

<h1>Logging Output &ndash; It&rsquo;s Like Butter</h1>

<p>When you add an item there are several things that could/should happen. Knowing at which point the failure happens is important. This is where Highway Framework makes things easier on you. We want to know where the operations are executing and how the context is operating on a configurable level. This is going to use the standard log levels to get output from the system. Consider the following Test.</p>

<p>```
[TestMethod]
public void ShouldLogAtDebugLevel()
{</p>

<pre><code>//arrange 
var logger = new ConsoleOutLogger("Testing", LogLevel.Debug, true, true, true, @"dd/mm/yyyy hh:mm:ss");
var target = new DataContext(Settings.Default.Connection, new DriversEducationMappings(), logger);

//act
target.Add(new Driver("Devlin", "Liles"));
target.Add(new Driver("Tim", "Rayburn"));
target.Add(new Driver("Jay", "Smith"));
target.Add(new Driver("Brian", "Sullivan"));
target.Add(new Driver("Cori", "Drew"));

target.Commit();

foreach (var driver in target.AsQueryable&lt;Driver&gt;())
{
    target.Remove(driver);
}

target.Commit();

//assert
Assert.Inconclusive("We fail here to get the output from console nice and easy");
</code></pre>

<p>}
```
The output from this test is below</p>

<p><code>plain
30/40/2013 05:40:07 [DEBUG] Testing - Adding Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing - Adding Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing - Adding Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing - Adding Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing - Adding Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing -   Commited 5 Changes
30/40/2013 05:40:07 [DEBUG] Testing - Querying Object Driver
30/40/2013 05:40:07 [DEBUG] Testing - Queried Object Driver
30/40/2013 05:40:07 [DEBUG] Testing - Removing Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing - Removing Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing - Removing Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing - Removing Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing - Removing Object Highway.DriversEducation.GettingStarted.Driver
30/40/2013 05:40:07 [DEBUG] Testing -   Commited 5 Changes
</code></p>

<p>You can see that you get the step by step of what the application is doing on Debug but if you want even more information, you can up the game with LogLevel.Trace &ndash; This will trace every action start and finish.</p>

<p><code>plain
10/30/2013 5:49:10 PM [DEBUG] Testing - Adding Object Highway.DriversEducation.GettingStarted.Driver
10/30/2013 5:49:10 PM [TRACE] Testing - Added Object Highway.DriversEducation.GettingStarted.Driver
...
10/30/2013 5:49:10 PM [TRACE] Testing -     Commit
10/30/2013 5:49:10 PM [DEBUG] Testing -     Commited 5 Changes
10/30/2013 5:49:10 PM [DEBUG] Testing - Querying Object Driver
10/30/2013 5:49:10 PM [DEBUG] Testing - Queried Object Driver
10/30/2013 5:49:10 PM [DEBUG] Testing - Removing Object Highway.DriversEducation.GettingStarted.Driver
10/30/2013 5:49:10 PM [TRACE] Testing - Removed Object
...
10/30/2013 5:49:10 PM [TRACE] Testing -     Commit
10/30/2013 5:49:10 PM [DEBUG] Testing -     Commited 5 Changes
</code></p>

<p>This log level also lets you see the guts of when the model binding hits are being taken.</p>

<p><code>plain
10/30/2013 5:51:47 PM [DEBUG] Testing - Adding Object Highway.DriversEducation.GettingStarted.Driver
10/30/2013 5:51:47 PM [DEBUG] Testing -     OnModelCreating
10/30/2013 5:51:47 PM [TRACE] Testing -         Mapping : DriversEducationMappings
</code></p>

<p>Or Even when we execute a function/stored procedure</p>

<p><code>plain
10/30/2013 5:54:16 PM [TRACE] Testing - Executing SQL Select * from Drivers Where LastName = @lastName, with parameters lastName : Liles : String   
</code>
If you have code that is reloading objects to refresh them from the database using <code>Reload&lt;T&gt;(T item)</code> then you would see something like this.</p>

<p>``` plain</p>

<pre><code>10/30/2013 5:56:49 PM [TRACE] Testing - Retrieving State Entry For Object Highway.DriversEducation.GettingStarted.Driver
10/30/2013 5:56:49 PM [DEBUG] Testing - Reloading Object Highway.DriversEducation.GettingStarted.Driver
10/30/2013 5:56:49 PM [TRACE] Testing - Reloaded Object Highway.DriversEducation.GettingStarted.Driver
</code></pre>

<p>```</p>

<p>Keep an eye out because in the next version we will be introducing the following logging features.</p>

<ol>
<li>Repository Level Logging of Queries/Commands/Scalars</li>
<li>Non-Debugging Levels for always on health logging of the DataContext</li>
<li>Performance Logging on Trace Level for Commits and Repository Level Items</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eager Loading with Queries and Scalars]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/28/eager-loading-with-queries-and-scalars/"/>
    <updated>2013-10-28T17:38:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/28/eager-loading-with-queries-and-scalars</id>
    <content type="html"><![CDATA[<p>When we define a query, sometimes we need to load a graph of related objects as well. This can be impressively helpful with an ORM, but it is also more expensive per query. We have to balance the cost of the query graph with the ease of loading related objects in the code base. The approach to this varies by the underlying ORM that you are using, so please click the link for the section that pertains to you.</p>

<p><a href="#ef">Entity Framework</a></p>

<p><a href="#nhibernate">NHibernate</a></p>

<h1>Example Domain</h1>

<p>In all of the examples below, we&rsquo;ll be working with the following business domain, from our Driver&rsquo;s Education company:</p>

<p>``` csharp
public class Instructor
{</p>

<pre><code>public int Id { get; set; }
public ICollection&lt;Driver&gt; Drivers { get; set; }
</code></pre>

<p>}</p>

<p>public class Driver
{</p>

<pre><code>public int Id { get; set; }
public string FirstName { get; set; }
public string LastName { get; set; }
public Car Car { get; set; }
</code></pre>

<p>}</p>

<p>public class Car
{</p>

<pre><code>public int Id { get; set; }
public string Make { get; set; }
public string Model { get; set; }
public string Year { get; set; }
</code></pre>

<p>}</p>

<p>public class InstructorById : Scalar<Instructor>
{</p>

<pre><code>public InstructorById(int id)
{
    ContextQuery = context =&gt; context.AsQueryable&lt;Instructor&gt;()
                                     .SingleOrDefault(e =&gt; e.Id == id);
}
</code></pre>

<p>}
```</p>

<h2>Use Case</h2>

<p>Let&rsquo;s assume that we now need to load Drivers and Cars for the instructor. Because we are only loading one Instructor this should be fairly light weight on the database.</p>

<p><a name="ef"></a></p>

<h1>Entity Framework</h1>

<p>Entity Framework got the API for this correct, so when you unit test this without a database it does nothing with the include call. This allows us to not need an advanced query for the Entity Framework version of the query.</p>

<p>```
public class InstructorById : Scalar<Instructor>
{</p>

<pre><code>public InstructorById(int id)
{
    ContextQuery = context =&gt; context.AsQueryable&lt;Instructor&gt;()
                                .Include(x =&gt; x.Drivers.Select(c =&gt; c.Car))
                                .SingleOrDefault(e =&gt; e.Id == id);
}
</code></pre>

<p>}
<code>``
Notice to traverse a collection we have to use the</code>Select` method, this is a quark of LINQ and Entity Framework. As you see below in the NHibernate solution there is a slightly more elegant way they could have done this, but it comes with a hefty cost.</p>

<p><a name="nhibernate"></a></p>

<h1>NHibernate</h1>

<p>In the NHibernate usage we will have to bind ourselves to their specific API, which means that we will have to use an <code>AdvancedQuery</code>.
```
public class InstructorById : AdvancedScalar<Instructor>
{</p>

<pre><code>public InstructorById(int id)
{
    ContextQuery = context =&gt; context.Query&lt;Instructor&gt;()
                                .FetchMany(x =&gt; x.Drivers)  
                                .ThenFetch(x =&gt; x.Car)
                                .SingleOrDefault(e =&gt; e.Id == id);
}
</code></pre>

<p>}
<code>
This reads more fluently but causes us to be bound to NHibernate. **It also has one massive bug in NHibernate's LINQ provider.** In the above query you will only get one related driver and one related car. This is because it applies a Top 1 to the queries. To avoid this you must do the below query.
</code>
public class InstructorById : AdvancedScalar<Instructor>
{</p>

<pre><code>public InstructorById(int id)
{
    ContextQuery = context =&gt; context.Query&lt;Instructor&gt;()
                                .FetchMany(x =&gt; x.Drivers)  
                                .ThenFetch(x =&gt; x.Car)
                                .Where(e =&gt; e.Id == id)
                                .ToList() // This forces execution without the Top 1 of a single or default
                                .SingleOrDefault();
}
</code></pre>

<p>}
```
<strong>This is a bug in NHibernate</strong></p>
]]></content>
  </entry>
  
</feed>
