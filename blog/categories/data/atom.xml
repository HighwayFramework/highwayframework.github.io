<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: data | The fastest and smoothest way to good architecture]]></title>
  <link href="http://hwyfwk.com/blog/categories/data/atom.xml" rel="self"/>
  <link href="http://hwyfwk.com/"/>
  <updated>2013-10-27T14:14:16-05:00</updated>
  <id>http://hwyfwk.com/</id>
  <author>
    <name><![CDATA[Tim Rayburn & Devlin Liles]]></name>
    <email><![CDATA[Team@HwyFwk.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Advanced Queries / Commands /Scalars]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/25/advanced-queries-slash-commands-slash-scalars/"/>
    <updated>2013-10-25T15:11:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/25/advanced-queries-slash-commands-slash-scalars</id>
    <content type="html"><![CDATA[<h1>Advanced Queries / Commands / Scalars</h1>

<p>Surround your pullquote like this {" text to be quoted "}</p>

<p>All of the <code>AdvancedQuery</code>, <code>AdvancedScalar</code>, and <code>AdvancedCommand</code> are an opt in process for one reason, <strong>it requires that you bind your implementation of the query to the underlying technology.</strong> This is not something to take lightly, but sometimes it is needed.</p>

<h1>Example Domain</h1>

<p>In all of the examples below, we&rsquo;ll be working with the following business domain, from our Driver&rsquo;s Education company:</p>

<p>```
public class Instructor
{</p>

<pre><code>public int Id { get; set; }
public ICollection&lt;Driver&gt; Drivers { get; set; }
</code></pre>

<p>}</p>

<p>public class Driver
{</p>

<pre><code>public int Id { get; set; }
public string FirstName { get; set; }
public string LastName { get; set; }
public int Score { get; set; }
public Instructor Instructor { get; set; }
</code></pre>

<p>}</p>

<p>public class Car
{</p>

<pre><code>public int Id { get; set; }
public string Make { get; set; }
public string Model { get; set; }
public string Year { get; set; }
</code></pre>

<p>}</p>

<p>public class Top5PercentileOfDrivers : Query<Driver>
{</p>

<pre><code>public Top5PercentileOfDrivers()
{
    ContextQuery = context =&gt;
    {
        var scores = context.AsQueryable&lt;Driver&gt;().Select(x =&gt; x.Score);
        int percentileScore =
            Convert.ToInt32(Math.Round((5/100)*scores.Count() + 0.5, MidpointRounding.AwayFromZero));
        return context.AsQueryable&lt;Driver&gt;().OrderByDescending(x =&gt; x.Score).Take(percentileScore);
    };
}
</code></pre>

<p>}</p>

<p>public class SwapInstructors : Scalar<int>
{</p>

<pre><code>public SwapInstructores(Instructor currentInstructor, Instructor newInstructor)
{
    ContextQuery = context =&gt;
    {
        foreach(var driver in currentInstructor.Drivers)
        {
            driver.Instructor = newInstructor;
        }
        context.Commit();
    };
}
</code></pre>

<p>}</p>

<p>public class DropMake : Command
{</p>

<pre><code>public DropMake(string make)
{
    // THIS IS A REALLY BAD WAY TO REMOVE MULTIPLE ROWS
    // IT WOULD NORMALLY BE MUCH BETTER TO USE AN
    // AdvancedCommand TO PERFORM THIS TYPE OF OPERATION
    ContextQuery = c =&gt;
    {
        var cars = c.AsQueryable&lt;Car&gt;().Where(car =&gt; car.Make == make);
        foreach (var car in cars)
        {
            c.Remove(car);
        }
    };
}
</code></pre>

<p>}
```</p>

<h1>Advanced Query &ndash; Sometimes you need a Stored Procedure</h1>

<p>In the case where we want to do large set based calculation it makes sense to use the power of the underlying persistence engine. Databases have been designed for set based operations, and here is where the power of stored procedures or parameterized SQL comes in. We are going to use a stored procedure to return the top 5 percentile of drivers that have used our training service. The advanced version of this would be below.</p>

<p>```
public class Top5PercentileOfDrivers : AdvancedQuery<Driver>
{</p>

<pre><code>public Top5PercentileOfDrivers()
{
    ContextQuery = context =&gt; context.ExecuteSqlQuery&lt;Driver&gt;("exec topPercentileDrivers @percentile", new SqlParameter("percentile",5));
}
</code></pre>

<p>}
```</p>

<h1>Advanced Commands &ndash;  When you need a hammer</h1>

<p>Surround your pullquote like this {" text to be quoted "}
```
public class DropMake : AdvancedCommand
{</p>

<pre><code>public DropMake(string make)
{
    ContextQuery = c =&gt; c.ExecuteSqlCommand("DELETE FROM Cars WHERE Make = @make",new DbParameter[] {new SqlParameter("make", make)});
}
</code></pre>

<p>}
```</p>

<h1>Advanced Scalar</h1>

<p>In the instance that we need to make a lot of changes but also return some value from the database, we can use an <code>AdvancedScalar</code>.
```
public class SwapInstructores : AdvancedScalar<int>
{</p>

<pre><code>public SwapInstructores(Instructor currentInstructor, Instructor newInstructor)
{
    DbParameter[] parameters = new DbParameter[]
    {
        new SqlParameter("old", currentInstructor.Id),
        new SqlParameter("new", newInstructor.Id), 
    };
    ContextQuery = c =&gt; c.ExecuteSqlCommand("UPDATE DRIVERS SET InstructorId = @new WHERE InstructorId = @old", parameters);
}
</code></pre>

<p>}
```</p>

<p>Each of these examples gives one of the many usages of <code>AdvancedQuery</code>/<code>AdvancedCommand</code>/<code>AdvancedScalar</code>, but when you need the underlying provider this is your route. When used carefully this allows us to serve both the the needs of our application, but also the needs of our data storage.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pagination Of Queries]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/25/pagination-of-queries/"/>
    <updated>2013-10-25T14:11:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/25/pagination-of-queries</id>
    <content type="html"><![CDATA[<h1>Paging Queries</h1>

<p>Surround your pullquote like this {" text to be quoted "}</p>

<h1>Example Domain</h1>

<p>In all of the examples below, we&rsquo;ll be working with the following business domain, from our Driver&rsquo;s Education company:</p>

<p>```
public class Instructor
{</p>

<pre><code>public int Id { get; set; }
public ICollection&lt;Driver&gt; Drivers { get; set; }
</code></pre>

<p>}</p>

<p>public class Driver
{</p>

<pre><code>public int Id { get; set; }
public string FirstName { get; set; }
public string LastName { get; set; }
public Car Car { get; set; }
</code></pre>

<p>}</p>

<p>public class Car
{</p>

<pre><code>public int Id { get; set; }
public string Make { get; set; }
public string Model { get; set; }
public string Year { get; set; }
</code></pre>

<p>}</p>

<p>public class DriversByLastName : Query<Driver>
{</p>

<pre><code>public DriversByLastName(string lastName)
{
    ContextQuery = context =&gt; context.AsQueryable&lt;Driver&gt;().Where(e =&gt; e.LastName == lastName);
}
</code></pre>

<p>}
```</p>

<h1>Paging The <code>IQuery</code> &ndash; LINQ style</h1>

<p>This method we chose for paging is one that should be familiar to the entire .NET community at this point. We are using <code>.Skip(int numberOfObjects)</code> and <code>.Take(int numberOfObjects)</code>. Take the following controller method to get drivers by name</p>

<p>```
public class DriversController : Controller
{</p>

<pre><code>private IRepository repo;

public DriversController(IRepository repo)
{
    this.repo = repo;
}

public ActionResult ByLastName(string lastName)
{
    IEnumerable&lt;Driver&gt; drivers = repo.Find(new DriversByLastName(lastName));
    return View(drivers);
}
</code></pre>

<p>}
<code>``
Now that we have a call to the database and out training school has been running for a while we realize that we have 500 "Smith"s in the database. This causes our view to be horrible, and we need to add paging to the call. This is as easy as modifying the usage of</code>Query` to do the following.</p>

<p>```
public class DriversController : Controller
{</p>

<pre><code>private IRepository repo;

public DriversController(IRepository repo)
{
    this.repo = repo;
}

public ActionResult ByLastName(string lastName, int page)
{
    var pageSize = 10;
    IEnumerable&lt;Driver&gt; drivers = repo.Find(new DriversByLastName(lastName)
                                                .Skip(page * pageSize).Take(pageSize));
    return View(drivers);
}
</code></pre>

<p>}
```
This allows us to reused already defined queries for our paging solution as well. <strong>This is one of the rare cases that you can modify the SQL of a query from outside the query</strong> This will only return the records that are inside the page that you have defined.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Highway.Data v4.1.0.2]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/22/highway-dot-data-v4-dot-1-0-dot-2/"/>
    <updated>2013-10-22T15:26:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/22/highway-dot-data-v4-dot-1-0-dot-2</id>
    <content type="html"><![CDATA[<h1>Changes</h1>

<ul>
<li>Removed an extraneous extension method called <code>Include</code> which was creating a conflict with the <code>System.Data.Entity</code> method of the same name.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding the Patterns]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/19/understanding-the-patterns/"/>
    <updated>2013-10-19T10:40:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/19/understanding-the-patterns</id>
    <content type="html"><![CDATA[<h1>Patterns</h1>

<p>Highway.Data is based on a blended use of <strong>3 major patterns</strong>, and to understand the intent of the Queries / Commands / Scalars that make highway smooth, we must first talk about the patterns.</p>

<p>There are a lot of places where you can find the academic explanation of these patterns, but here we are going to focus on the outcomes we are using it for. If you would like to read more about these, check out the <a href="#furtherReading">Further Reading</a> below.</p>

<h2>Repository</h2>

<p>Repository is a way to abstract the &ldquo;guts&rdquo; of the data access and persistence knowledge away from my logic. This is a lot of the time misused. Typed Repositories, Repositories with more than 5 methods, repositories that manage their own statefulness are all examples of a good pattern meeting a bad implementation. We use Repository in combination with Unit of Work and a modern interpretation of Query Object pattern.</p>

<h3>Signs of a well built Repository</h3>

<ul>
<li>The user of the repository ask for data, but no information about the persistence is leaked to the caller.</li>
<li>It is not specific to any domain, and can be portable</li>
<li>It has state, but doesn&rsquo;t manage it</li>
<li>It has no control of the Update/Add/Delete side of the operations, but gives access to that API. Repositories are meant as an abstraction for reading data.</li>
</ul>


<h2>Unit Of Work</h2>

<p>Unit of Work allows us to track in memory changes of an object that are made in series and then commit those changes to some persistence layer. This is an atomic unit of work that is transaction during the commit but in our code is just changes to objects.</p>

<h3>Signs of a well built unit of work</h3>

<ul>
<li>Commit-able</li>
<li>Abandon/Rollback-able</li>
<li>Not specific to any one API</li>
<li>Give the basic Add/Remove/Update functionality</li>
<li>Are not query-able</li>
</ul>


<h2>Query Object</h2>

<p>Query Object is a way of encapsulating the details of a single query into an object that can be reused without being stateful. This helps us avoid duplication in the code base and we can codify and test our queries.</p>

<h3>Signs of a well built query object</h3>

<ul>
<li>It doesn&rsquo;t manager state outside a single execution</li>
<li>It is reuse-able</li>
<li>It is able to be functionally tested</li>
<li>It is able to be performance tested</li>
<li>It can output it&rsquo;s persistence query ( SQL statement for example )</li>
<li>If it returns multiple rows, it can have pagination applied without modification</li>
</ul>


<p><a name="furtherReading"></a></p>

<h2>Further Reading</h2>

<p>We hold our opinions because of years of software development on all sizes of projects, but understand that many opinions exist that are valid. In an effort to present the information as impartially as possible below does include links to content that disagrees with our opinions. Please read on and form your own opinions.</p>

<h3>Repository</h3>

<p><a href="http://www.martinfowler.com/eaaCatalog/repository.html">Martin Fowler Repository Pattern</a></p>

<p><a href="http://weblogs.asp.net/fredriknormen/archive/2008/04/24/what-purpose-does-the-repository-pattern-have.aspx">Fredik Normén Repository Pattern Purpose Discussion</a></p>

<p><a href="http://msdn.microsoft.com/en-us/library/ff649690.aspx">MSDN Repository Article</a></p>

<p><a href="http://ayende.com/blog/4784/architecting-in-the-pit-of-doom-the-evils-of-the-repository-abstraction-layer">Ayende@Rahien Repository Pit Of Doom</a></p>

<p><a href="http://www.devlinliles.com/post/I-disagree-with-the-pit-of-Doom">Devlin Liles Discussion of the Pit Of Doom</a></p>

<h3>Unit of Work</h3>

<p><a href="http://www.martinfowler.com/eaaCatalog/unitOfWork.html">Martin Fowler Unit of Work</a></p>

<p><a href="http://msdn.microsoft.com/en-us/magazine/dd882510.aspx">Jeremy Miller Unit of Work and Persistence Ignorance</a></p>

<p><a href="http://rlacovara.blogspot.com/2009/04/entity-framework-patterns-unit-of-work.html">Ruby Lacovara Entity Framework Patterns Unit of Work</a></p>

<h3>Query Object</h3>

<p><a href="http://martinfowler.com/eaaCatalog/queryObject.html">Martin Fowler Query Object</a></p>

<p><a href="http://coderkarl.wordpress.com/2012/05/02/the-query-object-pattern-2/">Karl Nilsson Query Object Pattern</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Queries / Commands / Scalars]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/19/queries-slash-commands-slash-scalars/"/>
    <updated>2013-10-19T09:21:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/19/queries-slash-commands-slash-scalars</id>
    <content type="html"><![CDATA[<h1>Using Queries, Commands and Scalars</h1>

<p>The basis for separating concerns in Highway.Data is that the query object itself is the smallest level of data access and can be used to encapsulate the concerns of the &ldquo;How we get data&rdquo; from the &ldquo;What data do I get&rdquo;. In this post will we be diving into the reasoning, implementation, and usage of the different types of Query Objects included with Highway.Data.</p>

<ul>
<li><a href="/blog/2013/10/19/understanding-the-patterns/">Patterns</a></li>
<li><a href="#query">Query</a></li>
<li><a href="#command">Command</a></li>
<li><a href="#scalar">Scalar</a></li>
</ul>


<p><a name="query"></a></p>

<h1>Queries</h1>

<h2>Implementation</h2>

<p>Lets take a look at the definition of out basic Query interface
``` csharp
public interface IQuery<out T> : IQueryBase
{</p>

<pre><code>IEnumerable&lt;T&gt; Execute(IDataContext context);
</code></pre>

<p>}
<code>``
Execute is the function that our</code>Repository` will use to execute the query, and it will hand it the context to execute upon. This allows us to create queries without external dependencies, but also allows us to add additional behavior by creating our own context without breaking our queries.</p>

<h3>IEnumerable<T> Vs IQueryable<T></h3>

<p>Notice how the Execution of the query returns an <code>IEnumerable</code> instead of an <code>IQueryable</code>. This is to basically &ldquo;seal&rdquo; the SQL so that additional operations happen in memory. The horrors of lazy loading and LINQ allow us, as developers without realizing it, to load tremendous amounts of data into memory. We have taken steps to make sure that is an intentional choice rather than an unintended consequence.</p>

<h2>Usage</h2>

<p>The basic query selects a collection of objects that you tell it to as one operation. If we need to get drivers by last name, consider the following classes and tests.</p>

<h3>Classes Involved</h3>

<p>```
public class Driver { public string LastName { get; set; } }</p>

<p>public class DriversByLastName : Query<Driver>
{</p>

<pre><code>public DriversByLastName(string lastName)
{
    ContextQuery = context =&gt; context.AsQueryable&lt;Driver&gt;().Where(e =&gt; e.LastName == lastName);
}
</code></pre>

<p>}
<code>``
Notice how we inherit from the</code>Query<Driver><code>class. This class has most of the base logic for deferred execution and gives us an easy way to define queries. The type parameter of Driver tells us what the query will return. In one line we assign the</code>ContextQuery`, which is just a delegate to get called when we need the results.</p>

<h3>Tests</h3>

<p>For these tests we are using the <code>InMemoryDataContext</code> that ships with Highway.Data as a testable stub.</p>

<p>```
[TestMethod]
public void ShouldGetDriversByLastName()
{</p>

<pre><code>//Arrange
var context = new InMemoryDataContext();
context.Add(new Driver(){ LastName = "Liles" });
context.Add(new Driver(){ LastName = "Rayburn" });

var query = new DriversByLastName("Liles");

//Act
var results = query.Execute(context); 

//Assert
Assert.AreEqual(1, results.Count());
Assert.AreEqual("Liles",results.Single().LastName);
</code></pre>

<p>}
```</p>

<h3>Example Usage with repository</h3>

<p><code>
IEnumerable&lt;Driver&gt; = repository.Find(new DriversByLastName("Liles"));
</code></p>

<p><a name="command"></a></p>

<h1>Command</h1>

<h2>Implementation</h2>

<p>Lets take a look at the definition of out basic Command Interface
``` csharp
public interface ICommand
{</p>

<pre><code>void Execute(IDataContext context);
</code></pre>

<p>}
```
Execute is the function that our Repository will use to execute the command, and it will hand it the context to execute upon. This allows us to create commands without external dependencies, but also allows us to add additional behavior by creating our own context without breaking our commands.</p>

<h2>Usage</h2>

<p>The basic command allows us to fire off a set of operations without a return against our persistence store. This command could be updates, deletes, or even firing SQL Jobs. Lets consider the classes and tests involved</p>

<h3>Classes Involved</h3>

<p>```
public class Driver
{</p>

<pre><code>public int Score { get; set; }
public string LastName { get; set; } 
</code></pre>

<p>}</p>

<p>public class SetDriverScoreByLastName : Command
{</p>

<pre><code>public SetDriverScoreByLastName(string lastName, int score)
{
    ContextQuery = context =&gt; 
    {
        var drivers = context.AsQueryable&lt;Driver&gt;().Where(e =&gt; e.LastName == lastName);
        foreach(var driver in drivers)
        {
            driver.Score = score;
        }
        context.Commit();
    }
}
</code></pre>

<p>}
<code>``
Notice how we inherit from the</code>Command<code>class. This class has most of the base logic for deferred execution and gives us an easy way to define commands. We can set the</code>ContextQuery` to be a multiple line delegate like above, or a single operation.</p>

<blockquote><h3><strong><em>Commands are not deferred, they execute immediately</em></strong></h3></blockquote>

<h3>Tests</h3>

<p>For these tests we are using the <code>InMemoryDataContext</code> that ships with Highway.Data as a testable stub.</p>

<p>```
[TestMethod]
public void ShouldSetScoresByLastName()
{</p>

<pre><code>//Arrange
var context = new InMemoryDataContext();
context.Add(new Driver(){ LastName = "Liles" });
context.Add(new Driver(){ LastName = "Rayburn" });

var command = new SetDriverScoreByLastName("Liles", 100);

//Act
command.Execute(context); 

//Assert
var result = context.AsQueryable&lt;Driver&gt;().Single(x =&gt; x.LastName == "Liles"); 
Assert.AreEqual("Liles", results.LastName);
Assert.AreEqual(100, results.Score);
</code></pre>

<p>}
```</p>

<h3>Example Usage with repository</h3>

<p><code>
repository.Execute(new SetDriverScoreByLastName("Liles", 100));
</code></p>

<p><a name="scalar"></a></p>

<h1>Scalar</h1>

<h2>Implementation</h2>

<p>Lets take a look at the definition of out basic Scalar interface
``` csharp
public interface IScalar<out T>
{</p>

<pre><code>T Execute(IDataContext context);
</code></pre>

<p>}
```</p>

<h2>Usage</h2>

<p>The basic scalar selects a single object that you tell it to as one operation. If we need to get a driver by last name, consider the following classes and tests. we can also return out non entity types such as a count of drivers by score;</p>

<h3>Classes Involved</h3>

<p>```
public class Driver
{</p>

<pre><code>public int Score { get; set; }
public string LastName { get; set; } 
</code></pre>

<p>}</p>

<p>public class FirstDriverByLastName : Scalar<Driver>
{</p>

<pre><code>public FirstDriverByLastName(string lastName)
{
    ContextQuery = context =&gt; context.AsQueryable&lt;Driver&gt;().FirstOrDefault(e =&gt; e.LastName == lastName);
}
</code></pre>

<p>}</p>

<p>public class PassingDrivers : Scalar<int>
{</p>

<pre><code>public PassingDrivers()
{
    ContextQuery = context =&gt; context.AsQueryable&lt;Driver&gt;().Count(x =&gt; x.Score &gt; 75);
}
</code></pre>

<p>}
<code>``
Notice how we inherit from the</code>Scalar<Driver><code>or</code>Scalar<int>` class. The type parameter defines the type we are returning with the scalar, and the base class gives us all the logic to execute and log the information about the execution.</p>

<blockquote><h3><strong><em>Scalars are not deferred, they execute immediately</em></strong></h3></blockquote>

<h3>Tests</h3>

<p>For these tests we are using the <code>InMemoryDataContext</code> that ships with Highway.Data as a testable stub.</p>

<p>```
[TestMethod]
public void ShouldGetFirstDriverByLastName()
{</p>

<pre><code>//Arrange
var context = new InMemoryDataContext();
context.Add(new Driver(){ LastName = "Liles" });
context.Add(new Driver(){ LastName = "Rayburn" });

var query = new FirstDriverByLastName("Liles");

//Act
var result = query.Execute(context); 

//Assert
Assert.AreEqual("Liles",result.LastName);
</code></pre>

<p>}</p>

<p>[TestMethod]
public void ShouldGetCountOfPassingDrivers()
{</p>

<pre><code>//Arrange
var context = new InMemoryDataContext();
context.Add(new Driver(){ LastName = "Liles", Score = 50 });
context.Add(new Driver(){ LastName = "Rayburn", Score = 100 });

var query = new PassingDrivers();

//Act
var result = query.Execute(context); 

//Assert
Assert.AreEqual(1,result);
</code></pre>

<p>}
```</p>

<h3>Example Usage with repository</h3>

<p><code>
Driver driver = repository.Find(new DriverByLastName("Liles"));
int passingDrivers = repository.Find(new PassingDrivers());
</code></p>
]]></content>
  </entry>
  
</feed>
