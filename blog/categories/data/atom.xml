<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: data | The fastest and smoothest way to good architecture]]></title>
  <link href="http://hwyfwk.com/blog/categories/data/atom.xml" rel="self"/>
  <link href="http://hwyfwk.com/"/>
  <updated>2014-04-10T11:22:35-05:00</updated>
  <id>http://hwyfwk.com/</id>
  <author>
    <name><![CDATA[Tim Rayburn & Devlin Liles]]></name>
    <email><![CDATA[Team@HwyFwk.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Highway.Data v5.0.7 Released]]></title>
    <link href="http://hwyfwk.com/blog/2014/03/22/highway-dot-data-v5-dot-0-7-released/"/>
    <updated>2014-03-22T10:47:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2014/03/22/highway-dot-data-v5-dot-0-7-released</id>
    <content type="html"><![CDATA[<p>More contributions from, Eric Burcham and Long Mai!  Thank you gentlemen for your support.</p>

<ul>
<li>Bug Fix : <a href="https://github.com/HighwayFramework/Highway.Data/pull/56">GetById Documentation</a></li>
<li>Bug Fix : <a href="https://github.com/HighwayFramework/Highway.Data/pull/55">Additional Identity Strategies and Auto-increment Id for IIdentifiable&rsquo;s</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Highway.Data v5.0.6 Released]]></title>
    <link href="http://hwyfwk.com/blog/2014/03/15/highway-dot-data-v5-dot-0-6-released/"/>
    <updated>2014-03-15T10:47:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2014/03/15/highway-dot-data-v5-dot-0-6-released</id>
    <content type="html"><![CDATA[<p>More contributions from @longility in this release, and an incubating feature, which will be promoted to a full feature in a future release:</p>

<ul>
<li>Bug Fix : <a href="https://github.com/HighwayFramework/Highway.Data/pull/54">Support for bidirectional and circular entity references for InMemoryDataContext</a></li>
<li>Incubating Feature : <a href="https://github.com/HighwayFramework/Highway.Data/pull/53">New SQL Query objects for EF</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Highway.Data v5.0.5 Released]]></title>
    <link href="http://hwyfwk.com/blog/2014/03/10/highway-dot-data-v5-dot-0-5-released/"/>
    <updated>2014-03-10T10:47:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2014/03/10/highway-dot-data-v5-dot-0-5-released</id>
    <content type="html"><![CDATA[<p>This release is brought to you by two new contributors, Eric Burcham and Long Mai!  Thank you gentlemen for your support.</p>

<ul>
<li>Bug Fix : <a href="https://github.com/HighwayFramework/Highway.Data/pull/52">Support adding element directly and indirectly to InMemoryDataContext.</a></li>
<li>Bug Fix : <a href="https://github.com/HighwayFramework/Highway.Data/pull/51">Improved documentation for IDomainRepositoryFactory</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simplified Creation Patterns]]></title>
    <link href="http://hwyfwk.com/blog/2014/01/25/simplified-creation-patterns/"/>
    <updated>2014-01-25T16:45:00-06:00</updated>
    <id>http://hwyfwk.com/blog/2014/01/25/simplified-creation-patterns</id>
    <content type="html"><![CDATA[<h1>Simplified Creation Patterns</h1>

<h3>Repository Factory</h3>

<p>We wanted to provide a simple way to construct both domain repositories and simple Repositories. This lead us to create two different factories for repository. We ship a default factory for both of these, but we also ship interfaces for these as a test and extension point.</p>

<h4>Repository Factory</h4>

<p>This allows you to construct a simple repository that doesn&rsquo;t need any of the <code>DomainRepository</code> features.</p>

<p>```</p>

<pre><code>public interface IRepositoryFactory
{
    /// &lt;summary&gt;
    /// Creates a repository for the requested domain
    /// &lt;/summary&gt;
    /// &lt;returns&gt;Domain specific repository&lt;/returns&gt;
    IRepository Create();
}
</code></pre>

<p>```</p>

<h4>Domain Repository Factory</h4>

<p>This allows you construct a repository specific to any domain that the factory is dependent on.</p>

<p>```</p>

<pre><code>public interface IDomainRepositoryFactory
{

    /// &lt;summary&gt;
    /// Creates a repository for the specified &lt;see cref="IDomain"/&gt;
    /// &lt;/summary&gt;
    /// &lt;typeparam name="T"&gt;Domain for repository&lt;/typeparam&gt;
    /// &lt;returns&gt;&lt;see cref="IRepository"/&gt;&lt;/returns&gt;
    IRepository Create&lt;T&gt;() where T : class, IDomain;

    /// &lt;summary&gt;
    /// Creates a repository for the specified &lt;see cref="IDomain"/&gt;
    /// &lt;/summary&gt;
    /// &lt;param name="T"&gt;Domain for repository&lt;/param&gt;
    /// &lt;returns&gt;&lt;see cref="IRepository"/&gt;&lt;/returns&gt;
    IRepository Create(Type type);
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Domain Context]]></title>
    <link href="http://hwyfwk.com/blog/2014/01/25/domain-context/"/>
    <updated>2014-01-25T16:42:00-06:00</updated>
    <id>http://hwyfwk.com/blog/2014/01/25/domain-context</id>
    <content type="html"><![CDATA[<h1>Domain Context and Domain Driven Design (DDD) Patterns</h1>

<h2>Why did you support DDD?</h2>

<p>We have been working in large complex applications for the last several projects and found some rough edges around both business logic and data access. These edges come from not separating the business concepts effectively in code. Long running business sagas being isolated helped to solve this. We added this advanced support to Highway.Data to help make this easier for us, and those like us that have drank the DDD punch.</p>

<h2>How did you support DDD?</h2>

<p>We added a few classes to help support the ability to create domain bounded contexts. These use a generic type parameter to define which domain they contain, and also to segregate the in memory cache for mappings. This allows us to load differing views on similar objects.</p>

<h3>IDomainRepository</h3>

<p>This repository has the event interception events, as well as the bounded context.</p>

<p>``` csharp</p>

<pre><code>public interface IDomainRepository&lt;in T&gt; where T : class
{
    event EventHandler&lt;BeforeQuery&gt; BeforeQuery;

    event EventHandler&lt;BeforeScalar&gt; BeforeScalar;

    event EventHandler&lt;BeforeCommand&gt; BeforeCommand;

    event EventHandler&lt;AfterQuery&gt; AfterQuery;

    event EventHandler&lt;AfterScalar&gt; AfterScalar;

    event EventHandler&lt;AfterCommand&gt; AfterCommand;

    IDomainContext&lt;T&gt; DomainContext { get; } 
}
</code></pre>

<p>```</p>

<h3>IDomainContext</h3>

<p>This context holds the context level interception events, and is contrained to a <code>IDomain</code> type.</p>

<p>```</p>

<pre><code>public interface IDomainContext&lt;in T&gt; : IDataContext where T : class
{
    /// &lt;summary&gt;
    ///     The event fired just before the commit of the persistence
    /// &lt;/summary&gt;
    event EventHandler&lt;BeforeSave&gt; BeforeSave;

    /// &lt;summary&gt;
    ///     The event fired just after the commit of the persistence
    /// &lt;/summary&gt;
    event EventHandler&lt;AfterSave&gt; AfterSave;
}
</code></pre>

<p>```</p>

<h3>IDomain</h3>

<p>This is the interface that you implement to define a domain for your objects. It includes any event interceptors, context configurations, connection string, and object mappings.</p>

<p>```</p>

<pre><code>public interface IDomain
{
    string ConnectionString { get; }

    IMappingConfiguration Mappings { get;}

    IContextConfiguration Context { get; }

    List&lt;IInterceptor&gt; Events { get; }
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
