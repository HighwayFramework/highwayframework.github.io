<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: feature | The fastest and smoothest way to good architecture]]></title>
  <link href="http://hwyfwk.com/blog/categories/feature/atom.xml" rel="self"/>
  <link href="http://hwyfwk.com/"/>
  <updated>2013-10-29T10:00:53-05:00</updated>
  <id>http://hwyfwk.com/</id>
  <author>
    <name><![CDATA[Tim Rayburn & Devlin Liles]]></name>
    <email><![CDATA[Team@HwyFwk.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Logging]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/28/logging-with-datacontext/"/>
    <updated>2013-10-28T17:59:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/28/logging-with-datacontext</id>
    <content type="html"><![CDATA[<p>We all have written/supported an application that had zero logging. It is like playing two sided blindfolded chess in the dark. We didn&rsquo;t want to pass that on to the users of Highway so logging is backed right into the toolset. We rely on <a href="">Common.Logging 2.1.1.0</a> for our logging API, because this allows you, our users, to use your favorite logging facility. I am going to use a simple console logger for these examples, but it could be any Common.Logging adapter.</p>

<h1>Example Domain</h1>

<p>In all of the examples below, we&rsquo;ll be working with the following business domain, from our Driver&rsquo;s Education company:</p>

<p>```
public class Instructor
{</p>

<pre><code>public int Id { get; set; }
public ICollection&lt;Driver&gt; Drivers { get; set; }
</code></pre>

<p>}</p>

<p>public class Driver
{</p>

<pre><code>public int Id { get; set; }
public string FirstName { get; set; }
public string LastName { get; set; }
public Car Car { get; set; }
</code></pre>

<p>}</p>

<p>public class Car
{</p>

<pre><code>public int Id { get; set; }
public string Make { get; set; }
public string Model { get; set; }
public string Year { get; set; }
</code></pre>

<p>}
```</p>

<h1>Adding Items</h1>

<p>When you add an item there are several things that could/should happen. Knowing at which point the failure happens is important. This is where Highway Framework makes things easier on you.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eager Loading with Queries and Scalars]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/28/eager-loading-with-queries-and-scalars/"/>
    <updated>2013-10-28T17:38:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/28/eager-loading-with-queries-and-scalars</id>
    <content type="html"><![CDATA[<p>When we define a query, sometimes we need to load a graph of related objects as well. This can be impressively helpful with an ORM, but it is also more expensive per query. We have to balance the cost of the query graph with the ease of loading related objects in the code base. The approach to this varies by the underlying ORM that you are using, so please click the link for the section that pertains to you.</p>

<p><a href="#ef">Entity Framework</a></p>

<p><a href="#nhibernate">NHibernate</a></p>

<h1>Example Domain</h1>

<p>In all of the examples below, we&rsquo;ll be working with the following business domain, from our Driver&rsquo;s Education company:</p>

<p>```
public class Instructor
{</p>

<pre><code>public int Id { get; set; }
public ICollection&lt;Driver&gt; Drivers { get; set; }
</code></pre>

<p>}</p>

<p>public class Driver
{</p>

<pre><code>public int Id { get; set; }
public string FirstName { get; set; }
public string LastName { get; set; }
public Car Car { get; set; }
</code></pre>

<p>}</p>

<p>public class Car
{</p>

<pre><code>public int Id { get; set; }
public string Make { get; set; }
public string Model { get; set; }
public string Year { get; set; }
</code></pre>

<p>}</p>

<p>public class InstructorById : Scalar<Instructor>
{</p>

<pre><code>public InstructorById(int id)
{
    ContextQuery = context =&gt; context.AsQueryable&lt;Instructor&gt;()
                                     .SingleOrDefault(e =&gt; e.Id == id);
}
</code></pre>

<p>}
```</p>

<h2>Use Case</h2>

<p>Let&rsquo;s assume that we now need to load Drivers and Cars for the instructor. Because we are only loading one Instructor this should be fairly light weight on the database.</p>

<p><a name="ef"></a></p>

<h1>Entity Framework</h1>

<p>Entity Framework got the API for this correct, so when you unit test this without a database it does nothing with the include call. This allows us to not need an advanced query for the Entity Framework version of the query.</p>

<p>```
public class InstructorById : Scalar<Instructor>
{</p>

<pre><code>public InstructorById(int id)
{
    ContextQuery = context =&gt; context.AsQueryable&lt;Instructor&gt;()
                                .Include(x =&gt; x.Drivers.Select(c =&gt; c.Car))
                                .SingleOrDefault(e =&gt; e.Id == id);
}
</code></pre>

<p>}
<code>``
Notice to traverse a collection we have to use the</code>Select` method, this is a quark of LINQ and Entity Framework. As you see below in the NHibernate solution there is a slightly more elegant way they could have done this, but it comes with a hefty cost.</p>

<p><a name="nhibernate"></a></p>

<h1>NHibernate</h1>

<p>In the NHibernate usage we will have to bind ourselves to their specific API, which means that we will have to use an <code>AdvancedQuery</code>.
```
public class InstructorById : AdvancedScalar<Instructor>
{</p>

<pre><code>public InstructorById(int id)
{
    ContextQuery = context =&gt; context.Query&lt;Instructor&gt;()
                                .FetchMany(x =&gt; x.Drivers)  
                                .ThenFetch(x =&gt; x.Car)
                                .SingleOrDefault(e =&gt; e.Id == id);
}
</code></pre>

<p>}
<code>
This reads more fluently but causes us to be bound to NHibernate. **It also has one massive bug in NHibernate's LINQ provider.** In the above query you will only get one related driver and one related car. This is because it applies a Top 1 to the queries. To avoid this you must do the below query.
</code>
public class InstructorById : AdvancedScalar<Instructor>
{</p>

<pre><code>public InstructorById(int id)
{
    ContextQuery = context =&gt; context.Query&lt;Instructor&gt;()
                                .FetchMany(x =&gt; x.Drivers)  
                                .ThenFetch(x =&gt; x.Car)
                                .Where(e =&gt; e.Id == id)
                                .ToList() // This forces execution without the Top 1 of a single or default
                                .SingleOrDefault();
}
</code></pre>

<p>}
```
<strong>This is a bug in NHibernate</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Performance Testing Queries]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/27/performance-testing-queries/"/>
    <updated>2013-10-27T16:31:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/27/performance-testing-queries</id>
    <content type="html"><![CDATA[<p>When dealing with data access you should always adhere to Jackson&rsquo;s rules of optimization. For convenience they are right here:</p>

<h3>M.A. Jackson (Principles of Program Design, 1975) wrote:</h3>

<p><strong>Rule 1.</strong> Don&rsquo;t do it</p>

<p><strong>Rule 2. (for experts only)</strong> Don&rsquo;t do it yet.</p>

<p>Performance optimization should only be done when needed, but when you need to it should be easy to execute and to measure. With this in mind, Highway took some of the heavy lifting out of the hands of the developers. This is normally the tools that we will use to identify a query that is not performing up to par so we can change it. Let&rsquo;s take the previous example of deleting all cars of a certain make.</p>

<h1>Example Domain</h1>

<p>In all of the examples below, we&rsquo;ll be working with the following business domain, from our Driver&rsquo;s Education company:</p>

<p>```
public class Car
{</p>

<pre><code>public int Id { get; set; }
public string Make { get; set; }
public string Model { get; set; }
public string Year { get; set; }
</code></pre>

<p>}</p>

<p>public class DropMake : Command
{</p>

<pre><code>public DropMake(string make)
{
    // THIS IS A REALLY BAD WAY TO REMOVE MULTIPLE ROWS
    // IT WOULD NORMALLY BE MUCH BETTER TO USE AN
    // AdvancedCommand TO PERFORM THIS TYPE OF OPERATION
    ContextQuery = c =&gt;
    {
        var cars = c.AsQueryable&lt;Car&gt;().Where(car =&gt; car.Make == make);
        foreach (var car in cars)
        {
            c.Remove(car);
        }
    };
}
</code></pre>

<p>}
```</p>

<h1>Performance Tests</h1>

<h2>These should <em>ideally</em> run against production like data</h2>

<p>I am going to use a command for delete, but this could be just as easily done with a <code>Scalar</code> or <code>Query</code>.</p>

<p>We want to measure the time it takes to execute the query and measure it against our maximum. If you cannot define a specific maximum for the test, you should look at Jackson rule 1. If your maximum doesn&rsquo;t fail this test, look at Jackson rule 2.</p>

<p>```
[TestMethod]
public void ShouldDeleteInUnder250Milliseconds()
{</p>

<pre><code>var context = new DataContext(Settings.Default.Connection, new DataMappings());

var dropMake = new DropMake("Chevy");

dropMake.RunPerformanceTest(context,false,250);
</code></pre>

<p>}
```</p>

<p>If the time exceeds maximum the performance test will throw an exception which will fail the test. The time and expected are in the exception.</p>

<p>Let&rsquo;s take a closer look at this line
<code>
dropMake.RunPerformanceTest(context,false,250);
</code>
The 1st parameter, context, is the data connection we use to execute the test.</p>

<p>The 2nd parameter, false, is a flag telling us to include the start up time of the context in the total time. This is useful with ORMs like Entity Framework or NHibernate that have a large one time cost on start up. We give you the option of excluding that time from your evaluation.</p>

<p>The 3rd parameter, 250, is the total milliseconds allowed for the execution. If it exceeds this the test fails.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Advanced Queries / Commands /Scalars]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/25/advanced-queries-slash-commands-slash-scalars/"/>
    <updated>2013-10-25T15:11:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/25/advanced-queries-slash-commands-slash-scalars</id>
    <content type="html"><![CDATA[<p>Surround your pullquote like this {" text to be quoted "}</p>

<p>All of the <code>AdvancedQuery</code>, <code>AdvancedScalar</code>, and <code>AdvancedCommand</code> are an opt in process for one reason, <strong>it requires that you bind your implementation of the query to the underlying technology.</strong> This is not something to take lightly, but sometimes it is needed.</p>

<h1>Example Domain</h1>

<p>In all of the examples below, we&rsquo;ll be working with the following business domain, from our Driver&rsquo;s Education company:</p>

<p>```
public class Instructor
{</p>

<pre><code>public int Id { get; set; }
public ICollection&lt;Driver&gt; Drivers { get; set; }
</code></pre>

<p>}</p>

<p>public class Driver
{</p>

<pre><code>public int Id { get; set; }
public string FirstName { get; set; }
public string LastName { get; set; }
public int Score { get; set; }
public Instructor Instructor { get; set; }
</code></pre>

<p>}</p>

<p>public class Car
{</p>

<pre><code>public int Id { get; set; }
public string Make { get; set; }
public string Model { get; set; }
public string Year { get; set; }
</code></pre>

<p>}</p>

<p>public class Top5PercentileOfDrivers : Query<Driver>
{</p>

<pre><code>public Top5PercentileOfDrivers()
{
    ContextQuery = context =&gt;
    {
        var scores = context.AsQueryable&lt;Driver&gt;().Select(x =&gt; x.Score);
        int percentileScore =
            Convert.ToInt32(Math.Round((5/100)*scores.Count() + 0.5, MidpointRounding.AwayFromZero));
        return context.AsQueryable&lt;Driver&gt;().OrderByDescending(x =&gt; x.Score).Take(percentileScore);
    };
}
</code></pre>

<p>}</p>

<p>public class SwapInstructors : Scalar<int>
{</p>

<pre><code>public SwapInstructores(Instructor currentInstructor, Instructor newInstructor)
{
    ContextQuery = context =&gt;
    {
        foreach(var driver in currentInstructor.Drivers)
        {
            driver.Instructor = newInstructor;
        }
        context.Commit();
    };
}
</code></pre>

<p>}</p>

<p>public class DropMake : Command
{</p>

<pre><code>public DropMake(string make)
{
    // THIS IS A REALLY BAD WAY TO REMOVE MULTIPLE ROWS
    // IT WOULD NORMALLY BE MUCH BETTER TO USE AN
    // AdvancedCommand TO PERFORM THIS TYPE OF OPERATION
    ContextQuery = c =&gt;
    {
        var cars = c.AsQueryable&lt;Car&gt;().Where(car =&gt; car.Make == make);
        foreach (var car in cars)
        {
            c.Remove(car);
        }
    };
}
</code></pre>

<p>}
```</p>

<h1>Advanced Query &ndash; Sometimes you need a Stored Procedure</h1>

<p>In the case where we want to do large set based calculation it makes sense to use the power of the underlying persistence engine. Databases have been designed for set based operations, and here is where the power of stored procedures or parameterized SQL comes in. We are going to use a stored procedure to return the top 5 percentile of drivers that have used our training service. The advanced version of this would be below.</p>

<p>```
public class Top5PercentileOfDrivers : AdvancedQuery<Driver>
{</p>

<pre><code>public Top5PercentileOfDrivers()
{
    ContextQuery = context =&gt; context.ExecuteSqlQuery&lt;Driver&gt;("exec topPercentileDrivers @percentile", new SqlParameter("percentile",5));
}
</code></pre>

<p>}
```</p>

<h1>Advanced Commands &ndash;  When you need a hammer</h1>

<p>Surround your pullquote like this {" text to be quoted "}
```
public class DropMake : AdvancedCommand
{</p>

<pre><code>public DropMake(string make)
{
    ContextQuery = c =&gt; c.ExecuteSqlCommand("DELETE FROM Cars WHERE Make = @make",new DbParameter[] {new SqlParameter("make", make)});
}
</code></pre>

<p>}
```</p>

<h1>Advanced Scalar</h1>

<p>In the instance that we need to make a lot of changes but also return some value from the database, we can use an <code>AdvancedScalar</code>.
```
public class SwapInstructores : AdvancedScalar<int>
{</p>

<pre><code>public SwapInstructores(Instructor currentInstructor, Instructor newInstructor)
{
    DbParameter[] parameters = new DbParameter[]
    {
        new SqlParameter("old", currentInstructor.Id),
        new SqlParameter("new", newInstructor.Id), 
    };
    ContextQuery = c =&gt; c.ExecuteSqlCommand("UPDATE DRIVERS SET InstructorId = @new WHERE InstructorId = @old", parameters);
}
</code></pre>

<p>}
```</p>

<p>Each of these examples gives one of the many usages of <code>AdvancedQuery</code>/<code>AdvancedCommand</code>/<code>AdvancedScalar</code>, but when you need the underlying provider this is your route. When used carefully this allows us to serve both the the needs of our application, but also the needs of our data storage.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pagination Of Queries]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/25/pagination-of-queries/"/>
    <updated>2013-10-25T14:11:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/25/pagination-of-queries</id>
    <content type="html"><![CDATA[<h1>Paging Queries</h1>

<p>Surround your pullquote like this {" text to be quoted "}</p>

<h1>Example Domain</h1>

<p>In all of the examples below, we&rsquo;ll be working with the following business domain, from our Driver&rsquo;s Education company:</p>

<p>```
public class Instructor
{</p>

<pre><code>public int Id { get; set; }
public ICollection&lt;Driver&gt; Drivers { get; set; }
</code></pre>

<p>}</p>

<p>public class Driver
{</p>

<pre><code>public int Id { get; set; }
public string FirstName { get; set; }
public string LastName { get; set; }
public Car Car { get; set; }
</code></pre>

<p>}</p>

<p>public class Car
{</p>

<pre><code>public int Id { get; set; }
public string Make { get; set; }
public string Model { get; set; }
public string Year { get; set; }
</code></pre>

<p>}</p>

<p>public class DriversByLastName : Query<Driver>
{</p>

<pre><code>public DriversByLastName(string lastName)
{
    ContextQuery = context =&gt; context.AsQueryable&lt;Driver&gt;().Where(e =&gt; e.LastName == lastName);
}
</code></pre>

<p>}
```</p>

<h1>Paging The IQuery &ndash; LINQ style</h1>

<p>This method we chose for paging is one that should be familiar to the entire .NET community at this point. We are using <code>.Skip(int numberOfObjects)</code> and <code>.Take(int numberOfObjects)</code>. Take the following controller method to get drivers by name</p>

<p>```
public class DriversController : Controller
{</p>

<pre><code>private IRepository repo;

public DriversController(IRepository repo)
{
    this.repo = repo;
}

public ActionResult ByLastName(string lastName)
{
    IEnumerable&lt;Driver&gt; drivers = repo.Find(new DriversByLastName(lastName));
    return View(drivers);
}
</code></pre>

<p>}
<code>``
Now that we have a call to the database and out training school has been running for a while we realize that we have 500 "Smith"s in the database. This causes our view to be horrible, and we need to add paging to the call. This is as easy as modifying the usage of</code>Query` to do the following.</p>

<p>```
public class DriversController : Controller
{</p>

<pre><code>private IRepository repo;

public DriversController(IRepository repo)
{
    this.repo = repo;
}

public ActionResult ByLastName(string lastName, int page)
{
    var pageSize = 10;
    IEnumerable&lt;Driver&gt; drivers = repo.Find(new DriversByLastName(lastName)
                                                .Skip(page * pageSize).Take(pageSize));
    return View(drivers);
}
</code></pre>

<p>}
```
This allows us to reused already defined queries for our paging solution as well. <strong>This is one of the rare cases that you can modify the SQL of a query from outside the query</strong> This will only return the records that are inside the page that you have defined.</p>
]]></content>
  </entry>
  
</feed>
