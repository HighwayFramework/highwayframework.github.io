<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: onramp-mvc | The fastest and smoothest way to good architecture]]></title>
  <link href="http://hwyfwk.com/blog/categories/onramp-mvc/atom.xml" rel="self"/>
  <link href="http://hwyfwk.com/"/>
  <updated>2013-10-05T16:11:05-05:00</updated>
  <id>http://hwyfwk.com/</id>
  <author>
    <name><![CDATA[Tim Rayburn & Devlin Liles]]></name>
    <email><![CDATA[Team@HwyFwk.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[WebActivator for Composable Startup]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/05/webactivator-for-composable-startup/"/>
    <updated>2013-10-05T15:09:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/05/webactivator-for-composable-startup</id>
    <content type="html"><![CDATA[<p>The first and most important piece our OnRamp is the use of <a href="http://www.nuget.org/packages/WebActivatorEx/">WebActivator</a> to allow us to declare classes that will run either just before or just after the App_Start event of your ASP.NET application, or when your application shuts down.  This is accomplished using an assembly level attribute, pointing to a particular static class and method.</p>

<p>Consider the following class declaration from our <code>IoC.cs</code> file:</p>

<p>``` csharp
[assembly: WebActivator.PreApplicationStartMethod(typeof(Templates.App_Start.IoC), &ldquo;Startup&rdquo;)]
namespace Templates.App_Start
{</p>

<pre><code>public static class IoC
{
    public static void Startup()
    {
      // Details here described in the next featureâ€¦
    }
}
</code></pre>

<p>}
```</p>

<p>Note how we declare the <code>PreApplicationStartMethod</code>, and point to the type of <code>Templates.App_Start.IoC</code> and then the <code>"Startup"</code> string lets it know which method to run.  This results in our <code>IoC.Startup()</code> method being called before App_Start.</p>

<p>Just as there is <code>PreApplicationStartMethod</code>, there is also <code>PostApplicationStartMethod</code> and <code>ApplicationShutdownMethod</code>, both of which are used in our Logging wire up which will be discussed later.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Castle Windsor with Auto Discovered Installers]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/05/castle-windsor-with-auto-discovered-installers/"/>
    <updated>2013-10-05T15:07:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/05/castle-windsor-with-auto-discovered-installers</id>
    <content type="html"><![CDATA[<h1>Configuring Castle Windsor</h1>

<p>Dependency injection is a key part of good software development, it is the D or <a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID</a>, and yet is not something <a href="http://microsoft.com">Microsoft</a> ships a solution for.  As such, we have turned to the community and the long standing, well supported, king of IoC : <a href="http://docs.castleproject.org/Default.aspx?Page=MainPage&amp;NS=Windsor&amp;AspxAutoDetectCookieSupport=1">Castle.Windsor</a></p>

<p>We configure Windsor with a set of reasonable defaults, and enable a few features which some people may not be aware of, to make it is painless as possible.  In our <code>IoC.Startup()</code> method, we do the following:</p>

<p>``` csharp</p>

<pre><code>    [Obsolete("Container should never be accessed directly outside of App_Start")]
    public static IWindsorContainer Container { get; set; }

    public static void Startup()
    {
#pragma warning disable 618
        // Create the container
        Container = new WindsorContainer();

        // Add the Array Resolver, so we can take dependencies on T[]
        // while only registering T.
        Container.Kernel.Resolver.AddSubResolver(new ArrayResolver(Container.Kernel));

        // Register the kernel and container, in case an installer needs it.
        Container.Register(
            Component.For&lt;IKernel&gt;().Instance(Container.Kernel),
            Component.For&lt;IWindsorContainer&gt;().Instance(Container)
            );

        // Search for an use all installers in this application.
        Container.Install(FromAssembly.This());
#pragma warning restore 618
    }
</code></pre>

<p>```</p>

<p>We make your instance of <a href="http://docs.castleproject.org/Default.aspx?Page=MainPage&amp;NS=Windsor&amp;AspxAutoDetectCookieSupport=1">Castle.Windsor</a> available via <code>IoC.Container</code> but we have specifically marked that as <code>[Obsolete]</code> because you should not be accessing the container directly.  Instead, we want to encourage you to rely on our injection of dependencies into your Controllers, and never directly access the container outside of App_Start.</p>

<h2>Accessing the Container without an Obsolete Warning</h2>

<p>Now, on rare occasions there will be perfectly reasonable pragmatic reasons to need to access the container.  This is the reason why we have marked the <code>[Obsolete]</code> merely as a warning, and then included the <code>#pragma</code> statements to disable those warnings in places you are accepting the need to directly access the container.  When those occur, simply surround your code with :</p>

<p>```</p>

<pre><code>#pragma warning disable 618
#pragma warning restore 618
</code></pre>

<p>```</p>

<p>You should keep such sections small, and should be aware that the <code>#pragma</code> statements will also disable any other <code>[Obsolete]</code> warnings that occur between them, not just those for the <code>IoC.Container</code>.</p>

<h1>Discovering Installers</h1>

<p>Our code above includes one very small, but very powerful line that is worth highlighting:</p>

<p><code>
Container.Install(FromAssembly.This());
</code></p>

<p>This statement tells <a href="http://docs.castleproject.org/Default.aspx?Page=MainPage&amp;NS=Windsor&amp;AspxAutoDetectCookieSupport=1">Castle.Windsor</a> to scan the <strong>current assembly</strong>, looking for classes which implement the <code>IWindsorInstaller</code> interface, and to execute those components, allowing them to register components with the container.  This auto discovery is one of the best features of our IoC implementation, allowing you to segregate your registrations into small, related pieces, as you will see.</p>

<h1>Included Installers</h1>

<p>We have included several installers for you, in the various packages of Highway.OnRamp.MVC.   They are all located in the <code>Installers</code> folder of your MVC solution.  Here are their names and purposes:</p>

<ul>
<li>ControllerInstaller &ndash; Scans the current assembly for all types that implement <code>IController</code> from System.Web.Mvc and registers them with <a href="http://docs.castleproject.org/Default.aspx?Page=MainPage&amp;NS=Windsor&amp;AspxAutoDetectCookieSupport=1">Castle.Windsor</a>.  This means you never have to register your controllers manually.</li>
<li>LoggingInstaller &ndash; Configures the Castle Logging Facility, and wires it to NLog.  We will cover this is more detail when we discuss the Logging feature.</li>
<li>FilterInstaller &ndash; Is where you register all MVC filters.  We will cover this in more detail when we discuss Filter Injection.</li>
<li>HighwayDataInstaller &ndash; Is the configuration and registrations for using Highway.Data.EntityFramework for your database.  It will be covered in more detail when we discuss Data Access.</li>
</ul>

]]></content>
  </entry>
  
</feed>
