<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: onramp-mvc | The fastest and smoothest way to good architecture]]></title>
  <link href="http://hwyfwk.com/blog/categories/onramp-mvc/atom.xml" rel="self"/>
  <link href="http://hwyfwk.com/"/>
  <updated>2013-10-19T12:24:24-05:00</updated>
  <id>http://hwyfwk.com/</id>
  <author>
    <name><![CDATA[Tim Rayburn & Devlin Liles]]></name>
    <email><![CDATA[Team@HwyFwk.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Queries / Commands / Scalars]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/19/queries-slash-commands-slash-scalars/"/>
    <updated>2013-10-19T09:21:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/19/queries-slash-commands-slash-scalars</id>
    <content type="html"><![CDATA[<h1>Using Queries, Commands and Scalars</h1>

<p>The basis for separating concerns in Highway.Data is that the query object itself is the smallest level of data access and can be used to encapsulate the concerns of the &ldquo;How we get data&rdquo; from the &ldquo;What data do I get&rdquo;. In this post will we be diving into the reasoning, implementation, and usage of the different types of Query Objects included with Highway.Data.</p>

<ul>
<li><a href="/blog/2013/10/19/understanding-the-patterns/">Patterns</a></li>
<li><a href="#query">Query</a></li>
<li><a href="#command">Command</a></li>
<li><a href="#scalar">Scalar</a></li>
</ul>


<p><a name="query"></a></p>

<h1>Queries</h1>

<h2>Implementation</h2>

<p>Lets take a look at the definition of out basic Query interface
``` csharp
public interface IQuery<out T> : IQueryBase
{</p>

<pre><code>IEnumerable&lt;T&gt; Execute(IDataContext context);
</code></pre>

<p>}
<code>``
Execute is the function that our</code>Repository` will use to execute the query, and it will hand it the context to execute upon. This allows us to create queries without external dependencies, but also allows us to add additional behavior by creating our own context without breaking our queries.</p>

<h3>IEnumerable<T> Vs IQueryable<T></h3>

<p>Notice how the Execution of the query returns an <code>IEnumerable</code> instead of an <code>IQueryable</code>. This is to basically &ldquo;seal&rdquo; the SQL so that additional operations happen in memory. The horrors of lazy loading and LINQ allow us, as developers without realizing it, to load tremendous amounts of data into memory. We have taken steps to make sure that is an intentional choice rather than an unintended consequence.</p>

<h2>Usage</h2>

<p>The basic query selects a collection of objects that you tell it to as one operation. If we need to get drivers by last name, consider the following classes and tests.</p>

<h3>Classes Involved</h3>

<p>```
public class Driver { public string LastName { get; set; } }</p>

<p>public class DriversByLastName : Query<Driver>
{</p>

<pre><code>public DriversByLastName(string lastName)
{
    ContextQuery = context =&gt; context.AsQueryable&lt;Driver&gt;().Where(e =&gt; e.LastName == lastName);
}
</code></pre>

<p>}
<code>``
Notice how we inherit from the</code>Query<Driver><code>class. This class has most of the base logic for deferred execution and gives us an easy way to define queries. The type parameter of Driver tells us what the query will return. In one line we assign the</code>ContextQuery`, which is just a delegate to get called when we need the results.</p>

<h3>Tests</h3>

<p>For these tests we are using the <code>InMemoryDataContext</code> that ships with Highway.Data as a testable stub.</p>

<p>```
[TestMethod]
public void ShouldGetDriversByLastName()
{</p>

<pre><code>//Arrange
var context = new InMemoryDataContext();
context.Add(new Driver(){ LastName = "Liles" });
context.Add(new Driver(){ LastName = "Rayburn" });

var query = new DriversByLastName("Liles");

//Act
var results = query.Execute(context); 

//Assert
Assert.AreEqual(1, results.Count());
Assert.AreEqual("Liles",results.Single().LastName);
</code></pre>

<p>}
```</p>

<h3>Example Usage with repository</h3>

<p><code>
IEnumerable&lt;Driver&gt; = repository.Find(new DriversByLastName("Liles"));
</code></p>

<p><a name="command"></a></p>

<h1>Command</h1>

<h2>Implementation</h2>

<p>Lets take a look at the definition of out basic Command Interface
``` csharp
public interface ICommand
{</p>

<pre><code>void Execute(IDataContext context);
</code></pre>

<p>}
```
Execute is the function that our Repository will use to execute the command, and it will hand it the context to execute upon. This allows us to create commands without external dependencies, but also allows us to add additional behavior by creating our own context without breaking our commands.</p>

<h2>Usage</h2>

<p>The basic command allows us to fire off a set of operations without a return against our persistence store. This command could be updates, deletes, or even firing SQL Jobs. Lets consider the classes and tests involved</p>

<h3>Classes Involved</h3>

<p>```
public class Driver
{</p>

<pre><code>public int Score { get; set; }
public string LastName { get; set; } 
</code></pre>

<p>}</p>

<p>public class SetDriverScoreByLastName : Command
{</p>

<pre><code>public SetDriverScoreByLastName(string lastName, int score)
{
    ContextQuery = context =&gt; 
    {
        var drivers = context.AsQueryable&lt;Driver&gt;().Where(e =&gt; e.LastName == lastName);
        foreach(var driver in drivers)
        {
            driver.Score = score;
        }
        context.Commit();
    }
}
</code></pre>

<p>}
<code>``
Notice how we inherit from the</code>Command<code>class. This class has most of the base logic for deferred execution and gives us an easy way to define commands. We can set the</code>ContextQuery` to be a multiple line delegate like above, or a single operation.</p>

<blockquote><h3><strong><em>Commands are not deferred, they execute immediately</em></strong></h3></blockquote>

<h3>Tests</h3>

<p>For these tests we are using the <code>InMemoryDataContext</code> that ships with Highway.Data as a testable stub.</p>

<p>```
[TestMethod]
public void ShouldSetScoresByLastName()
{</p>

<pre><code>//Arrange
var context = new InMemoryDataContext();
context.Add(new Driver(){ LastName = "Liles" });
context.Add(new Driver(){ LastName = "Rayburn" });

var command = new SetDriverScoreByLastName("Liles", 100);

//Act
command.Execute(context); 

//Assert
var result = context.AsQueryable&lt;Driver&gt;().Single(x =&gt; x.LastName == "Liles"); 
Assert.AreEqual("Liles", results.LastName);
Assert.AreEqual(100, results.Score);
</code></pre>

<p>}
```</p>

<h3>Example Usage with repository</h3>

<p><code>
repository.Execute(new SetDriverScoreByLastName("Liles", 100));
</code></p>

<p><a name="scalar"></a></p>

<h1>Scalar</h1>

<h2>Implementation</h2>

<p>Lets take a look at the definition of out basic Scalar interface
``` csharp
public interface IScalar<out T>
{</p>

<pre><code>T Execute(IDataContext context);
</code></pre>

<p>}
```</p>

<h2>Usage</h2>

<p>The basic scalar selects a single object that you tell it to as one operation. If we need to get a driver by last name, consider the following classes and tests. we can also return out non entity types such as a count of drivers by score;</p>

<h3>Classes Involved</h3>

<p>```
public class Driver
{</p>

<pre><code>public int Score { get; set; }
public string LastName { get; set; } 
</code></pre>

<p>}</p>

<p>public class FirstDriverByLastName : Scalar<Driver>
{</p>

<pre><code>public FirstDriverByLastName(string lastName)
{
    ContextQuery = context =&gt; context.AsQueryable&lt;Driver&gt;().FirstOrDefault(e =&gt; e.LastName == lastName);
}
</code></pre>

<p>}</p>

<p>public class PassingDrivers : Scalar<int>
{</p>

<pre><code>public PassingDrivers()
{
    ContextQuery = context =&gt; context.AsQueryable&lt;Driver&gt;().Count(x =&gt; x.Score &gt; 75);
}
</code></pre>

<p>}
<code>``
Notice how we inherit from the</code>Scalar<Driver><code>or</code>Scalar<int>` class. The type parameter defines the type we are returning with the scalar, and the base class gives us all the logic to execute and log the information about the execution.</p>

<blockquote><h3><strong><em>Scalars are not deferred, they execute immediately</em></strong></h3></blockquote>

<h3>Tests</h3>

<p>For these tests we are using the <code>InMemoryDataContext</code> that ships with Highway.Data as a testable stub.</p>

<p>```
[TestMethod]
public void ShouldGetFirstDriverByLastName()
{</p>

<pre><code>//Arrange
var context = new InMemoryDataContext();
context.Add(new Driver(){ LastName = "Liles" });
context.Add(new Driver(){ LastName = "Rayburn" });

var query = new FirstDriverByLastName("Liles");

//Act
var result = query.Execute(context); 

//Assert
Assert.AreEqual("Liles",result.LastName);
</code></pre>

<p>}</p>

<p>[TestMethod]
public void ShouldGetCountOfPassingDrivers()
{</p>

<pre><code>//Arrange
var context = new InMemoryDataContext();
context.Add(new Driver(){ LastName = "Liles", Score = 50 });
context.Add(new Driver(){ LastName = "Rayburn", Score = 100 });

var query = new PassingDrivers();

//Act
var result = query.Execute(context); 

//Assert
Assert.AreEqual(1,result);
</code></pre>

<p>}
```</p>

<h3>Example Usage with repository</h3>

<p><code>
Driver driver = repository.Find(new DriverByLastName("Liles"));
int passingDrivers = repository.Find(new PassingDrivers());
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Roadmaps]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/19/roadmaps/"/>
    <updated>2013-10-19T08:38:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/19/roadmaps</id>
    <content type="html"><![CDATA[<p>Below is the current road map for the Highway Framework. All of these are subject to change, but we want to be as transparent as possible in planning so that we can gather input from the community. Any project not in the list is considered stable and not in need of changes in the next 6 months.</p>

<!-- MORE -->


<h1>Highway.Data</h1>

<h2>vNext &ndash; Time line &ndash; Q4 2013</h2>

<ul>
<li>By end of the year all features release to have written tutorials, and the API to have updated documentation</li>
<li>By end of the year EF 6.0 major features that need additional work in the framework will be supported and documented</li>
</ul>


<h2>vNext + 1 &ndash; Time line &ndash; Q1 2014</h2>

<ul>
<li>Context and Repository will have factories for creation that control lifetime of the objects</li>
<li>Projection based Scalars &ndash; Scalars will be converted to projection based to allow for SQL output,</li>
<li>Documentation &ndash; Video Tutorials for 80% features</li>
</ul>


<h1>Highway.Insurance</h1>

<h2>vNext &ndash; Time line &ndash; Q4 2013</h2>

<ul>
<li>By end of the year all features release to have written tutorials, and the API to have updated documentation</li>
<li>Version Support for VS 2013 APIs</li>
</ul>


<h2>vNext + 1 &ndash; Time line &ndash; Q1 2014</h2>

<ul>
<li>Video Tutorials for 80% features</li>
</ul>


<h1>Highway.Pavement</h1>

<h2>vNext &ndash; Time line &ndash; Q4 2013</h2>

<ul>
<li>By end of the year all features release to have written tutorials, and the API to have updated documentation</li>
</ul>


<h1>Highway.MVC &ndash; New Project</h1>

<h2>vFirst &ndash; Time line &ndash; Q4 2013</h2>

<ul>
<li>Package a set of classes that allow for MVVM Model hydration to Knockout or Angular by default from MVC Model</li>
<li>All feature documentation and usage video tutorials</li>
</ul>


<h1>Highway.OnRamp.MVC.MVVM &ndash; New Project</h1>

<h2>vFirst &ndash; Time line &ndash; Q4 2013</h2>

<ul>
<li>OnRamp to drop MVVM wire up and folder structure into any MVC project &ndash; Even Existing</li>
<li>Video to walk through basic structure</li>
</ul>


<h1>Highway.OnRamp.MVC</h1>

<h2>vNext &ndash; Timeline &ndash; Q4 2013</h2>

<ul>
<li>Documentation of all current features (70%+ complete already)</li>
<li>Reorganize solution structure to move most inserted classes into an App_Infrastructure folder</li>
<li>Introduce default conventions for &ldquo;Post<em>&rdquo; and &ldquo;Get</em>&rdquo; actions to be limited to HttpPost and HttpGet respectively via Filter injection.</li>
</ul>


<h1>Highway.RoadCrew</h1>

<h2>vFirst</h2>

<ul>
<li>Implement all currently listed stories/issues to establish a great foundation</li>
<li>Document all those features on the website, as completed.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MVC Filters with Dependency Injection]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/06/mvc-filters-with-dependency-injection/"/>
    <updated>2013-10-06T20:39:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/06/mvc-filters-with-dependency-injection</id>
    <content type="html"><![CDATA[<p>One of the most powerful features of the MVC OnRamp is the ability to have MVC Filters injected via our Inversion of Control (IoC) container, Castle.Windsor.  There are several types of filters supported by ASP.NET MVC that allow you to handle orthogonal issues such as:</p>

<ul>
<li><code>IExceptionFilter</code> which is invoked whenever unhandled exceptions occur.</li>
<li><code>IActionFilter</code> which is invoked just before and just after specific actions.</li>
<li><code>IAuthorizationFilter</code> which is invoked when authorizing requests.</li>
<li><code>IResultFilter</code> which is invoked on just before and just after results are returned.</li>
</ul>


<p>Normally these filters are applied one of two ways:</p>

<ul>
<li>Globally via specification in the App_Start, which can easily be resolved from the IoC container but which must be global in scope, and hence somewhat limiting.</li>
<li>Via Attribute on either a Controller or Action, which cannot be resolved from the IoC because we have no control over the instantiation of those attributes.</li>
</ul>


<p>But MVC allows for another option, which is an <code>IFilterProvider</code>, this interface is called at the outset of any request, and is allowed to return at runtime instances of filters which are to be applied.  Using this interface, we have created a class that resolves filters from within Castle.Windsor.  Consider the following class:</p>

<p>``` csharp
public class IoCFilterProvider : IFilterProvider
{</p>

<pre><code>private readonly IEnumerable&lt;Func&lt;ControllerContext, ActionDescriptor, Filter&gt;&gt; registeredFilters;

public IoCFilterProvider(Func&lt;ControllerContext, ActionDescriptor, Filter&gt;[] registeredFilters)
{
    this.registeredFilters = registeredFilters;
}

public IEnumerable&lt;Filter&gt; GetFilters(ControllerContext controllerContext, ActionDescriptor actionDescriptor)
{
    return registeredFilters.Select(m =&gt; m.Invoke(controllerContext, actionDescriptor)).Where(m =&gt; m != null);
}
</code></pre>

<p>}
```</p>

<p>This simple class takes as a dependencies an array of delegates, speficically an array of <code>Func&lt;&gt;</code> delegates which receive as parameters the <code>ControllerContext</code> and <code>ActionDescriptor</code> and which return an instance of the <code>Filter</code> class.</p>

<ul>
<li>The <code>ControllerContext</code> class describes the controller that is about to be called.</li>
<li>The <code>ActionDescriptor</code> class describes the action on that controller which is about to be called.</li>
</ul>


<p>Given this information, you can decide to either return a <code>Filter</code> which will be applied, or return a null which will take no action.</p>

<h1>How do I register a filter?</h1>

<p>In our <code>FilterInstaller</code> class you will see an example of registering such a filter:</p>

<p>``` csharp
public class FilterInstaller : IWindsorInstaller
{</p>

<pre><code>public void Install(IWindsorContainer container, IConfigurationStore store)
{
    container.Register(
        Component.For&lt;IFilterProvider&gt;().ImplementedBy&lt;IoCFilterProvider&gt;(),
        Component.For&lt;ExceptionLoggingFilter&gt;().ImplementedBy&lt;ExceptionLoggingFilter&gt;(),
        Component.For&lt;Func&lt;ControllerContext,ActionDescriptor,Filter&gt;&gt;().Instance(
            (c,a) =&gt; new Filter(container.Resolve&lt;ExceptionLoggingFilter&gt;(), FilterScope.Last, int.MinValue))
        );
}
</code></pre>

<p>}
```</p>

<p>On line 8, we register a <code>Func&lt;ControllerContext,ActionDescriptor,Filter&gt;</code> and state that we will provide a specific instance of that delegate to be used.</p>

<p>On line 9, we use the lambda syntax to declare a delegate, which is provided <code>(c,a)</code> as the parameters of type <code>ControllerContext</code> and <code>ActionDescriptor</code>, and which has a body of:</p>

<p><code>csharp
new Filter(container.Resolve&lt;ExceptionLoggingFilter&gt;(), FilterScope.Last, int.MinValue)
</code></p>

<p>In this simple case, we create an instance of the <code>System.Web.Mvc.Filter</code> class and provide it our <code>ExceptionLoggingFilter</code> resolved from the container, and then tell the Filter to run in the <code>FilterScope.Last</code>, aka run this filter after all others, and order it within that scope using the <code>int.MinValue</code>, aka I really mean last of all last filters.</p>

<p>You can easily extend these registrations to include other filters by simply registering their delegates with the container and deciding when to return an instance of <code>Filter</code> and when to return <code>null</code> based on your business need.  Our example always returns, because we want to always log exceptions, but that is not required.  If your delegate examines the input data and determines it does not need to run a filter, simply return <code>null</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NLog and Castle Logging Facility for Logging]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/06/nlog-and-castle-logging-facility-for-logging/"/>
    <updated>2013-10-06T08:50:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/06/nlog-and-castle-logging-facility-for-logging</id>
    <content type="html"><![CDATA[<p>One of the most important features of any application is a good logging strategy.  Because of this, <code>Highway.OnRamp.MVC.Logging</code> brings together two very well established projects to provide a world class logging experience.  First, we use the <a href="http://docs.castleproject.org/Windsor.Logging-Facility.ashx">Castle Logging Facility</a> to provide a common abstraction over logging, so you are not coupled to a specific logging framework.  Then we implement <a href="http://nlog-project.org/">NLog</a> to perform the actual logging, configuring it via the <code>NLog.config</code> file.</p>

<h1>How do I log from a class?</h1>

<p>If you want to log from a class, there is a very simply pattern we recommend you follow:</p>

<p>``` csharp
using Castle.Core.Logging;</p>

<p>public class MyNewClass
{</p>

<pre><code>public MyNewClass()
{
    Logger = NullLogger.Instance;
}

public ILogger Logger { get; set; }
</code></pre>

<p>}
```</p>

<p>The steps are quite simple:</p>

<ul>
<li>Declare a public property of type <code>ILogger</code></li>
<li>Initialize that property in your constructor to <code>NullLogger.Instance</code></li>
</ul>


<p>This uses the ability of Castle.Windsor to do Property injection, so that after you class is constructed Castle Windsor will assign the real logger to that <code>Logger</code> property.  But, if you ever remove the <code>LoggingInstaller</code> your code will continue to work because the <code>NullLogger</code> is a proper implementation of <code>ILogger</code> which does nothing.  This avoids <code>NullReferenceException</code>s when you don&rsquo;t have a Logger injected, for instance during tests.</p>

<h1>How does that get setup to begin with?</h1>

<p>The Logging Facility is setup in the <code>LoggingInstaller</code> class, where we configure it.  A facility is a Castle.Windsor concept for a bundled set of registrations and behaviors.  As you can see, this makes properly configuring something like NLog very easy:</p>

<p>``` csharp
public class LoggingInstaller : IWindsorInstaller
{</p>

<pre><code>public void Install(IWindsorContainer container, IConfigurationStore store)
{

    container.AddFacility&lt;LoggingFacility&gt;(m =&gt; m.UseNLog().WithConfig("NLog.config"));
}
</code></pre>

<p>}
```</p>

<p>That really is all there is to it, we configure the facility to use NLog, and then tell it where the config file is.  Now, the config file we include is very simple:</p>

<p>``` xml
&lt;nlog xmlns=&ldquo;<a href="http://www.nlog-project.org/schemas/NLog.xsd">http://www.nlog-project.org/schemas/NLog.xsd</a>&rdquo;</p>

<pre><code>  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  autoReload="true"
  globalThreshold="Debug"&gt;
</code></pre>

<p>  <targets></p>

<pre><code>&lt;target xsi:type="File"
        name="file"
        fileName="${basedir}/Logs/Log.txt"
        archiveEvery="Day" /&gt;
</code></pre>

<p>  </targets></p>

<p>  <rules></p>

<pre><code>&lt;logger name="*" minlevel="Debug" writeTo="file" /&gt;
</code></pre>

<p>  </rules>
</nlog>
```</p>

<p>This configuration sets up a <code>Logs</code> directory that will contain <code>Log.txt</code> as a file which will be archived to another file every day.  It also configures NLog to log all messages Debug and above by default.  Not that while NLog supports a Trace level, below Debug, Castle Logging Facility does not so this essentially says &ldquo;log everything to Logs.txt&rdquo;.  There is a great deal more that can be done with NLog and I encourage you to <a href="https://github.com/nlog/nlog/wiki">review their documentation on config</a>.</p>

<h1>What is logged automatically for me?</h1>

<p>We setup two types of loggers for you automatically;</p>

<ul>
<li>The App_Start component <code>LoggerAnnouncementsWireup</code> logs a message every time your application starts up, and if it properly shuts down.</li>
<li>The filter <code>ExceptionLoggingFilter</code> logs every exception that is unhandled by the application.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WebActivator for Composable Startup]]></title>
    <link href="http://hwyfwk.com/blog/2013/10/05/webactivator-for-composable-startup/"/>
    <updated>2013-10-05T15:09:00-05:00</updated>
    <id>http://hwyfwk.com/blog/2013/10/05/webactivator-for-composable-startup</id>
    <content type="html"><![CDATA[<p>The first and most important piece our OnRamp is the use of <a href="http://www.nuget.org/packages/WebActivatorEx/">WebActivator</a> to allow us to declare classes that will run either just before or just after the App_Start event of your ASP.NET application, or when your application shuts down.  This is accomplished using an assembly level attribute, pointing to a particular static class and method.</p>

<p>Consider the following class declaration from our <code>IoC.cs</code> file:</p>

<p>``` csharp
[assembly: WebActivator.PreApplicationStartMethod(typeof(Templates.App_Start.IoC), &ldquo;Startup&rdquo;)]
namespace Templates.App_Start
{</p>

<pre><code>public static class IoC
{
    public static void Startup()
    {
      // Details here described in the next featureâ€¦
    }
}
</code></pre>

<p>}
```</p>

<p>Note how we declare the <code>PreApplicationStartMethod</code>, and point to the type of <code>Templates.App_Start.IoC</code> and then the <code>"Startup"</code> string lets it know which method to run.  This results in our <code>IoC.Startup()</code> method being called before App_Start.</p>

<p>Just as there is <code>PreApplicationStartMethod</code>, there is also <code>PostApplicationStartMethod</code> and <code>ApplicationShutdownMethod</code>, both of which are used in our Logging wire up which will be discussed later.</p>
]]></content>
  </entry>
  
</feed>
